{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar React = require(\"react\");\n/********************************\n* import files needed for splitter to work\n********************************/\n\n\nvar Pane_1 = require(\"./Pane\");\n\nvar HandleBar_1 = require(\"./HandleBar\");\n\nvar Helpers_1 = require(\"./Helpers\");\n\nrequire(\"./splitters.css\");\n\nvar Splitter =\n/** @class */\nfunction (_super) {\n  __extends(Splitter, _super);\n\n  function Splitter(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.handleMouseDown = function (e) {\n      /********************************\n      * If the right button was clicked - stop the function\n      * If there is more then one pane, we get the sizes of panes + max pos of mouse in splitter\n      * add event listener for touch move and mouse move\n      ********************************/\n      if (e.button === 2 || _this.props.allowResize === false) {\n        return;\n      }\n\n      var target = e.currentTarget;\n      var handleBarOffsetFromParent;\n      var clientX;\n      var clientY;\n\n      if (e.type === 'mousedown') {\n        clientX = e.clientX;\n        clientY = e.clientY;\n      } else if (e.type === 'touchstart') {\n        clientX = e.touches[0].clientX;\n        clientY = e.touches[0].clientY;\n      }\n\n      if (React.Children.count(_this.props.children) > 1) {\n        _this.getSize(clientX, clientY);\n      }\n\n      if (_this.props.position === 'horizontal') {\n        handleBarOffsetFromParent = clientY - target.offsetTop;\n      } else if (_this.props.position === 'vertical') {\n        handleBarOffsetFromParent = clientX - target.offsetLeft;\n      }\n\n      _this.setState({\n        isDragging: true,\n        handleBarOffsetFromParent: handleBarOffsetFromParent\n      });\n\n      document.addEventListener('mousemove', _this.handleMouseMove);\n      document.addEventListener('touchmove', _this.handleMouseMove);\n    };\n\n    _this.handleMouseMove = function (e) {\n      /********************************\n      * check if the state is still isDragging, if not, stop the function\n      * unselectAll - unselect all selected text\n      * check position of mouse in the splitter and and set the width or height of primary pane\n      * save last positions of X and Y coords (that is necessary for touch screen)\n      ********************************/\n      if (!_this.state.isDragging) {\n        return;\n      }\n\n      Helpers_1.unselectAll();\n      var _a = _this.state,\n          handleBarOffsetFromParent = _a.handleBarOffsetFromParent,\n          maxMousePosition = _a.maxMousePosition;\n      var _b = _this.props,\n          position = _b.position,\n          primaryPaneMinWidth = _b.primaryPaneMinWidth,\n          primaryPaneMinHeight = _b.primaryPaneMinHeight,\n          postPoned = _b.postPoned;\n      var clientX;\n      var clientY;\n\n      if (e.type === 'mousemove') {\n        clientX = e.clientX;\n        clientY = e.clientY;\n      } else if (e.type === 'touchmove') {\n        clientX = e.touches[0].clientX;\n        clientY = e.touches[0].clientY;\n      }\n\n      var primaryPanePosition = Helpers_1.getPrimaryPaneWidth(position, clientX, clientY, maxMousePosition, handleBarOffsetFromParent, primaryPaneMinHeight, primaryPaneMinWidth);\n\n      if (postPoned) {\n        _this.setState({\n          handleBarClonePosition: primaryPanePosition,\n          lastX: clientX,\n          lastY: clientY,\n          isVisible: true\n        });\n      } else {\n        _this.setState({\n          primaryPane: primaryPanePosition,\n          lastX: clientX,\n          lastY: clientY\n        });\n      }\n    };\n\n    _this.handleMouseUp = function (e) {\n      /********************************\n      * Dispatch event is for components which resizes on window resize\n      ********************************/\n      if (!_this.state.isDragging) {\n        return;\n      }\n\n      var _a = _this.state,\n          handleBarOffsetFromParent = _a.handleBarOffsetFromParent,\n          lastX = _a.lastX,\n          lastY = _a.lastY,\n          maxMousePosition = _a.maxMousePosition;\n      var _b = _this.props,\n          position = _b.position,\n          primaryPaneMinWidth = _b.primaryPaneMinWidth,\n          primaryPaneMinHeight = _b.primaryPaneMinHeight,\n          postPoned = _b.postPoned;\n      var primaryPanePosition = Helpers_1.getPrimaryPaneWidth(position, lastX, lastY, maxMousePosition, handleBarOffsetFromParent, primaryPaneMinHeight, primaryPaneMinWidth);\n\n      if (postPoned) {\n        _this.setState({\n          isDragging: false,\n          isVisible: false,\n          primaryPane: primaryPanePosition\n        });\n      } else {\n        _this.setState({\n          isDragging: false,\n          primaryPane: primaryPanePosition\n        });\n      }\n\n      document.removeEventListener('mousemove', _this.handleMouseMove);\n      document.removeEventListener('touchmove', _this.handleMouseMove); // call resize event to trigger method for updating of DataGrid width\n      // TODO: add this event for IE11\n\n      if (typeof _this.props.dispatchResize === 'boolean') {\n        window.dispatchEvent(new Event('resize'));\n      } // callback function from parent component\n\n\n      if (typeof _this.props.onDragFinished === 'function') {\n        _this.props.onDragFinished();\n      }\n\n      if (React.Children.count(_this.props.children) > 1) {\n        _this.getSize(lastX, lastY);\n      }\n    };\n\n    _this.getSize = function (cX, cY) {\n      /********************************\n      * This function calculates the max position of a mouse in the current splitter from given percentage.\n      /********************************/\n      var maxMousePosition;\n      var nodeWrapperSize;\n      var primaryPaneOffset;\n\n      var wrapper = _this.paneWrapper.getBoundingClientRect();\n\n      var primaryPane = _this.panePrimary.getDivInstance().getBoundingClientRect();\n\n      var handleBarSize = _this.handlebar.getDivInstance().getBoundingClientRect();\n\n      var posInHandleBar = _this.props.position === 'vertical' ? handleBarSize.left - cX : handleBarSize.top - cY; // find only letters from string\n\n      var regEx = new RegExp(/\\D+/gi);\n\n      if (_this.props.position === 'vertical') {\n        // split the maxWidth/maxHeight string to string and numbers\n        var maxWidthStr = _this.props.primaryPaneMaxWidth.match(regEx)[0].toLowerCase();\n\n        var maxWidthNum = parseFloat(_this.props.primaryPaneMaxWidth.split(regEx)[0]);\n        nodeWrapperSize = wrapper.width;\n        primaryPaneOffset = primaryPane.left;\n\n        if (maxWidthStr === '%') {\n          maxMousePosition = Math.floor(nodeWrapperSize * (maxWidthNum / 100) + primaryPaneOffset - (handleBarSize.width + posInHandleBar));\n        } else if (maxWidthStr === 'px') {\n          maxMousePosition = Math.floor(maxWidthNum + primaryPaneOffset - handleBarSize.width);\n        }\n      } else {\n        var maxHeightStr = _this.props.primaryPaneMaxHeight.match(regEx)[0].toLowerCase();\n\n        var maxHeightNum = parseFloat(_this.props.primaryPaneMaxHeight.split(regEx)[0]);\n        nodeWrapperSize = wrapper.height;\n        primaryPaneOffset = primaryPane.top;\n\n        if (maxHeightStr === '%') {\n          maxMousePosition = Math.floor(nodeWrapperSize * (maxHeightNum / 100) + primaryPaneOffset - (handleBarSize.height + posInHandleBar));\n        } else if (maxHeightStr === 'px') {\n          maxMousePosition = Math.floor(maxHeightNum + primaryPaneOffset - handleBarSize.height);\n        }\n      }\n\n      _this.setState({\n        maxMousePosition: maxMousePosition\n      });\n    };\n\n    _this.state = {\n      isDragging: false\n    };\n    return _this;\n  }\n\n  Splitter.prototype.componentDidMount = function () {\n    /********************************\n    * Sets event listeners after component is mounted.\n    * If there is only one pane, the resize event listener won't be added\n    ********************************/\n    document.addEventListener('mouseup', this.handleMouseUp);\n    document.addEventListener('touchend', this.handleMouseUp);\n\n    if (React.Children.count(this.props.children) > 1) {\n      window.addEventListener('resize', this.getSize);\n    }\n  };\n\n  Splitter.prototype.render = function () {\n    var _this = this;\n\n    var _a;\n    /********************************\n     * set width of primary pane according to props, or state\n    ********************************/\n\n\n    var _b = this.props,\n        children = _b.children,\n        position = _b.position,\n        primaryPaneMinWidth = _b.primaryPaneMinWidth,\n        primaryPaneWidth = _b.primaryPaneWidth,\n        primaryPaneMaxWidth = _b.primaryPaneMaxWidth,\n        primaryPaneMinHeight = _b.primaryPaneMinHeight,\n        primaryPaneHeight = _b.primaryPaneHeight,\n        primaryPaneMaxHeight = _b.primaryPaneMaxHeight,\n        className = _b.className,\n        primaryPaneClassName = _b.primaryPaneClassName,\n        secondaryPaneClassName = _b.secondaryPaneClassName,\n        maximizedPrimaryPane = _b.maximizedPrimaryPane,\n        minimalizedPrimaryPane = _b.minimalizedPrimaryPane,\n        postPoned = _b.postPoned,\n        allowResize = _b.allowResize;\n    var _c = this.state,\n        handleBarClonePosition = _c.handleBarClonePosition,\n        primaryPane = _c.primaryPane,\n        isVisible = _c.isVisible;\n    var paneStyle;\n\n    switch (position) {\n      case 'vertical':\n        {\n          if (maximizedPrimaryPane) {\n            paneStyle = {\n              width: '100%',\n              minWidth: primaryPaneMinWidth,\n              maxWidth: '100%'\n            };\n          } else if (minimalizedPrimaryPane) {\n            paneStyle = {\n              width: '0px',\n              minWidth: 0,\n              maxWidth: primaryPaneMaxWidth\n            };\n          } else {\n            paneStyle = {\n              width: primaryPane ? primaryPane + \"px\" : primaryPaneWidth,\n              minWidth: primaryPaneMinWidth,\n              maxWidth: primaryPaneMaxWidth\n            };\n          }\n\n          break;\n        }\n\n      case 'horizontal':\n        {\n          if (maximizedPrimaryPane) {\n            paneStyle = {\n              height: '100%',\n              minHeight: 0,\n              maxHeight: '100%'\n            };\n          } else if (minimalizedPrimaryPane) {\n            paneStyle = {\n              height: '0px',\n              minHeight: 0,\n              maxHeight: primaryPaneMaxHeight\n            };\n          } else {\n            paneStyle = {\n              height: primaryPane ? primaryPane + \"px\" : primaryPaneHeight,\n              minHeight: primaryPaneMinHeight,\n              maxHeight: primaryPaneMaxHeight\n            };\n          }\n\n          break;\n        }\n\n      default:\n        return null;\n    }\n\n    if (!children[1]) {\n      var onePaneStyle = {\n        width: '100%',\n        maxWidth: '100%',\n        height: '100%'\n      };\n    }\n\n    var handlebarClone;\n\n    if (React.Children.count(children) > 1 && postPoned) {\n      handlebarClone = (_a = {}, _a[position === 'vertical' ? 'left' : 'top'] = handleBarClonePosition + 'px', _a);\n    }\n\n    var handleBarCloneClassName = ['handle-bar handle-bar_clone', position === 'vertical' ? 'vertical' : 'horizontal'].join(' ');\n    return React.createElement(\"div\", {\n      className: \"splitter \" + (position === 'vertical' ? 'vertical' : 'horizontal') + \" \" + (className || ''),\n      style: onePaneStyle !== 'undefined' ? onePaneStyle : null,\n      ref: function ref(node) {\n        return _this.paneWrapper = node;\n      }\n    }, React.createElement(Pane_1.default, {\n      className: \"primary \" + (primaryPaneClassName || ''),\n      position: position,\n      style: paneStyle,\n      ref: function ref(node) {\n        return _this.panePrimary = node;\n      }\n    }, !children[1] ? children : children[0]), children[1] ? React.createElement(HandleBar_1.default, {\n      position: position,\n      handleMouseDown: this.handleMouseDown,\n      ref: function ref(node) {\n        return _this.handlebar = node;\n      },\n      allowResize: allowResize\n    }) : null, postPoned && isVisible ? React.createElement(\"div\", {\n      style: handlebarClone,\n      className: handleBarCloneClassName\n    }) : null, children[1] ? React.createElement(Pane_1.default, {\n      className: secondaryPaneClassName || '',\n      position: position,\n      hasDetailPane: this.props.hasDetailPane,\n      ref: function ref(node) {\n        return _this.paneNotPrimary = node;\n      }\n    }, children[1]) : null);\n  };\n\n  Splitter.defaultProps = {\n    position: 'vertical',\n    postPoned: false,\n    dispatchResize: false,\n    primaryPaneMaxWidth: '80%',\n    primaryPaneMinWidth: 300,\n    primaryPaneWidth: '50%',\n    primaryPaneMaxHeight: '80%',\n    primaryPaneMinHeight: 300,\n    primaryPaneHeight: '50%'\n  };\n  return Splitter;\n}(React.Component);\n\nexports.Splitter = Splitter;","map":null,"metadata":{},"sourceType":"script"}