{"ast":null,"code":"import { AutoSizer, List } from 'react-virtualized';\nimport isEqual from 'lodash.isequal';\nimport withScrolling, { createScrollingComponent, createVerticalStrength, createHorizontalStrength } from 'frontend-collective-react-dnd-scrollzone';\nimport React, { Component, Children, cloneElement } from 'react';\nimport PropTypes from 'prop-types';\nimport { DragDropContext, DragSource, DropTarget, DragDropContextConsumer } from 'react-dnd';\nimport HTML5Backend from 'react-dnd-html5-backend';\nimport { findDOMNode } from 'react-dom';\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nfunction componentWillMount() {\n  // Call this.constructor.gDSFP to support sub-classes.\n  var state = this.constructor.getDerivedStateFromProps(this.props, this.state);\n\n  if (state !== null && state !== undefined) {\n    this.setState(state);\n  }\n}\n\nfunction componentWillReceiveProps(nextProps) {\n  // Call this.constructor.gDSFP to support sub-classes.\n  // Use the setState() updater to ensure state isn't stale in certain edge cases.\n  function updater(prevState) {\n    var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);\n    return state !== null && state !== undefined ? state : null;\n  } // Binding \"this\" is important for shallow renderer support.\n\n\n  this.setState(updater.bind(this));\n}\n\nfunction componentWillUpdate(nextProps, nextState) {\n  try {\n    var prevProps = this.props;\n    var prevState = this.state;\n    this.props = nextProps;\n    this.state = nextState;\n    this.__reactInternalSnapshotFlag = true;\n    this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(prevProps, prevState);\n  } finally {\n    this.props = prevProps;\n    this.state = prevState;\n  }\n} // React may warn about cWM/cWRP/cWU methods being deprecated.\n// Add a flag to suppress these warnings for this special case.\n\n\ncomponentWillMount.__suppressDeprecationWarning = true;\ncomponentWillReceiveProps.__suppressDeprecationWarning = true;\ncomponentWillUpdate.__suppressDeprecationWarning = true;\n\nfunction polyfill(Component$$1) {\n  var prototype = Component$$1.prototype;\n\n  if (!prototype || !prototype.isReactComponent) {\n    throw new Error('Can only polyfill class components');\n  }\n\n  if (typeof Component$$1.getDerivedStateFromProps !== 'function' && typeof prototype.getSnapshotBeforeUpdate !== 'function') {\n    return Component$$1;\n  } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n  // Error if any of these lifecycles are present,\n  // Because they would work differently between older and newer (16.3+) versions of React.\n\n\n  var foundWillMountName = null;\n  var foundWillReceivePropsName = null;\n  var foundWillUpdateName = null;\n\n  if (typeof prototype.componentWillMount === 'function') {\n    foundWillMountName = 'componentWillMount';\n  } else if (typeof prototype.UNSAFE_componentWillMount === 'function') {\n    foundWillMountName = 'UNSAFE_componentWillMount';\n  }\n\n  if (typeof prototype.componentWillReceiveProps === 'function') {\n    foundWillReceivePropsName = 'componentWillReceiveProps';\n  } else if (typeof prototype.UNSAFE_componentWillReceiveProps === 'function') {\n    foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n  }\n\n  if (typeof prototype.componentWillUpdate === 'function') {\n    foundWillUpdateName = 'componentWillUpdate';\n  } else if (typeof prototype.UNSAFE_componentWillUpdate === 'function') {\n    foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n  }\n\n  if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n    var componentName = Component$$1.displayName || Component$$1.name;\n    var newApiName = typeof Component$$1.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';\n    throw Error('Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' + componentName + ' uses ' + newApiName + ' but also contains the following legacy lifecycles:' + (foundWillMountName !== null ? '\\n  ' + foundWillMountName : '') + (foundWillReceivePropsName !== null ? '\\n  ' + foundWillReceivePropsName : '') + (foundWillUpdateName !== null ? '\\n  ' + foundWillUpdateName : '') + '\\n\\nThe above lifecycles should be removed. Learn more about this warning here:\\n' + 'https://fb.me/react-async-component-lifecycle-hooks');\n  } // React <= 16.2 does not support static getDerivedStateFromProps.\n  // As a workaround, use cWM and cWRP to invoke the new static lifecycle.\n  // Newer versions of React will ignore these lifecycles if gDSFP exists.\n\n\n  if (typeof Component$$1.getDerivedStateFromProps === 'function') {\n    prototype.componentWillMount = componentWillMount;\n    prototype.componentWillReceiveProps = componentWillReceiveProps;\n  } // React <= 16.2 does not support getSnapshotBeforeUpdate.\n  // As a workaround, use cWU to invoke the new lifecycle.\n  // Newer versions of React will ignore that lifecycle if gSBU exists.\n\n\n  if (typeof prototype.getSnapshotBeforeUpdate === 'function') {\n    if (typeof prototype.componentDidUpdate !== 'function') {\n      throw new Error('Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype');\n    }\n\n    prototype.componentWillUpdate = componentWillUpdate;\n    var componentDidUpdate = prototype.componentDidUpdate;\n\n    prototype.componentDidUpdate = function componentDidUpdatePolyfill(prevProps, prevState, maybeSnapshot) {\n      // 16.3+ will not execute our will-update method;\n      // It will pass a snapshot value to did-update though.\n      // Older versions will require our polyfilled will-update value.\n      // We need to handle both cases, but can't just check for the presence of \"maybeSnapshot\",\n      // Because for <= 15.x versions this might be a \"prevContext\" object.\n      // We also can't just check \"__reactInternalSnapshot\",\n      // Because get-snapshot might return a falsy value.\n      // So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.\n      var snapshot = this.__reactInternalSnapshotFlag ? this.__reactInternalSnapshot : maybeSnapshot;\n      componentDidUpdate.call(this, prevProps, prevState, snapshot);\n    };\n  }\n\n  return Component$$1;\n} // very simple className utility for creating a classname string...\n// Falsy arguments are ignored:\n//\n// const active = true\n// const className = classnames(\n//    \"class1\",\n//    !active && \"class2\",\n//    active && \"class3\"\n// ); // returns -> class1 class3\";\n//\n\n\nfunction classnames() {\n  for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {\n    classes[_key] = arguments[_key];\n  } // Use Boolean constructor as a filter callback\n  // Allows for loose type truthy/falsey checks\n  // Boolean(\"\") === false;\n  // Boolean(false) === false;\n  // Boolean(undefined) === false;\n  // Boolean(null) === false;\n  // Boolean(0) === false;\n  // Boolean(\"classname\") === true;\n\n\n  return classes.filter(Boolean).join(' ');\n}\n\nvar TreeNode =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(TreeNode, _Component);\n\n  function TreeNode() {\n    _classCallCheck(this, TreeNode);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(TreeNode).apply(this, arguments));\n  }\n\n  _createClass(TreeNode, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          children = _this$props.children,\n          listIndex = _this$props.listIndex,\n          swapFrom = _this$props.swapFrom,\n          swapLength = _this$props.swapLength,\n          swapDepth = _this$props.swapDepth,\n          scaffoldBlockPxWidth = _this$props.scaffoldBlockPxWidth,\n          lowerSiblingCounts = _this$props.lowerSiblingCounts,\n          connectDropTarget = _this$props.connectDropTarget,\n          isOver = _this$props.isOver,\n          draggedNode = _this$props.draggedNode,\n          canDrop = _this$props.canDrop,\n          treeIndex = _this$props.treeIndex,\n          treeId = _this$props.treeId,\n          getPrevRow = _this$props.getPrevRow,\n          node = _this$props.node,\n          path = _this$props.path,\n          rowDirection = _this$props.rowDirection,\n          otherProps = _objectWithoutProperties(_this$props, [\"children\", \"listIndex\", \"swapFrom\", \"swapLength\", \"swapDepth\", \"scaffoldBlockPxWidth\", \"lowerSiblingCounts\", \"connectDropTarget\", \"isOver\", \"draggedNode\", \"canDrop\", \"treeIndex\", \"treeId\", \"getPrevRow\", \"node\", \"path\", \"rowDirection\"]);\n\n      var rowDirectionClass = rowDirection === 'rtl' ? 'rst__rtl' : null; // Construct the scaffold representing the structure of the tree\n\n      var scaffoldBlockCount = lowerSiblingCounts.length;\n      var scaffold = [];\n      lowerSiblingCounts.forEach(function (lowerSiblingCount, i) {\n        var lineClass = '';\n\n        if (lowerSiblingCount > 0) {\n          // At this level in the tree, the nodes had sibling nodes further down\n          if (listIndex === 0) {\n            // Top-left corner of the tree\n            // +-----+\n            // |     |\n            // |  +--+\n            // |  |  |\n            // +--+--+\n            lineClass = 'rst__lineHalfHorizontalRight rst__lineHalfVerticalBottom';\n          } else if (i === scaffoldBlockCount - 1) {\n            // Last scaffold block in the row, right before the row content\n            // +--+--+\n            // |  |  |\n            // |  +--+\n            // |  |  |\n            // +--+--+\n            lineClass = 'rst__lineHalfHorizontalRight rst__lineFullVertical';\n          } else {\n            // Simply connecting the line extending down to the next sibling on this level\n            // +--+--+\n            // |  |  |\n            // |  |  |\n            // |  |  |\n            // +--+--+\n            lineClass = 'rst__lineFullVertical';\n          }\n        } else if (listIndex === 0) {\n          // Top-left corner of the tree, but has no siblings\n          // +-----+\n          // |     |\n          // |  +--+\n          // |     |\n          // +-----+\n          lineClass = 'rst__lineHalfHorizontalRight';\n        } else if (i === scaffoldBlockCount - 1) {\n          // The last or only node in this level of the tree\n          // +--+--+\n          // |  |  |\n          // |  +--+\n          // |     |\n          // +-----+\n          lineClass = 'rst__lineHalfVerticalTop rst__lineHalfHorizontalRight';\n        }\n\n        scaffold.push(React.createElement(\"div\", {\n          key: \"pre_\".concat(1 + i),\n          style: {\n            width: scaffoldBlockPxWidth\n          },\n          className: classnames('rst__lineBlock', lineClass, rowDirectionClass)\n        }));\n\n        if (treeIndex !== listIndex && i === swapDepth) {\n          // This row has been shifted, and is at the depth of\n          // the line pointing to the new destination\n          var highlightLineClass = '';\n\n          if (listIndex === swapFrom + swapLength - 1) {\n            // This block is on the bottom (target) line\n            // This block points at the target block (where the row will go when released)\n            highlightLineClass = 'rst__highlightBottomLeftCorner';\n          } else if (treeIndex === swapFrom) {\n            // This block is on the top (source) line\n            highlightLineClass = 'rst__highlightTopLeftCorner';\n          } else {\n            // This block is between the bottom and top\n            highlightLineClass = 'rst__highlightLineVertical';\n          }\n\n          var _style;\n\n          if (rowDirection === 'rtl') {\n            _style = {\n              width: scaffoldBlockPxWidth,\n              right: scaffoldBlockPxWidth * i\n            };\n          } else {\n            // Default ltr\n            _style = {\n              width: scaffoldBlockPxWidth,\n              left: scaffoldBlockPxWidth * i\n            };\n          }\n\n          scaffold.push(React.createElement(\"div\", {\n            // eslint-disable-next-line react/no-array-index-key\n            key: i,\n            style: _style,\n            className: classnames('rst__absoluteLineBlock', highlightLineClass, rowDirectionClass)\n          }));\n        }\n      });\n      var style;\n\n      if (rowDirection === 'rtl') {\n        style = {\n          right: scaffoldBlockPxWidth * scaffoldBlockCount\n        };\n      } else {\n        // Default ltr\n        style = {\n          left: scaffoldBlockPxWidth * scaffoldBlockCount\n        };\n      }\n\n      return connectDropTarget(React.createElement(\"div\", _extends({}, otherProps, {\n        className: classnames('rst__node', rowDirectionClass)\n      }), scaffold, React.createElement(\"div\", {\n        className: \"rst__nodeContent\",\n        style: style\n      }, Children.map(children, function (child) {\n        return cloneElement(child, {\n          isOver: isOver,\n          canDrop: canDrop,\n          draggedNode: draggedNode\n        });\n      }))));\n    }\n  }]);\n\n  return TreeNode;\n}(Component);\n\nTreeNode.defaultProps = {\n  swapFrom: null,\n  swapDepth: null,\n  swapLength: null,\n  canDrop: false,\n  draggedNode: null,\n  rowDirection: 'ltr'\n};\nTreeNode.propTypes = {\n  treeIndex: PropTypes.number.isRequired,\n  treeId: PropTypes.string.isRequired,\n  swapFrom: PropTypes.number,\n  swapDepth: PropTypes.number,\n  swapLength: PropTypes.number,\n  scaffoldBlockPxWidth: PropTypes.number.isRequired,\n  lowerSiblingCounts: PropTypes.arrayOf(PropTypes.number).isRequired,\n  listIndex: PropTypes.number.isRequired,\n  children: PropTypes.node.isRequired,\n  // Drop target\n  connectDropTarget: PropTypes.func.isRequired,\n  isOver: PropTypes.bool.isRequired,\n  canDrop: PropTypes.bool,\n  draggedNode: PropTypes.shape({}),\n  // used in dndManager\n  getPrevRow: PropTypes.func.isRequired,\n  node: PropTypes.shape({}).isRequired,\n  path: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number])).isRequired,\n  // rtl support\n  rowDirection: PropTypes.string\n};\n/**\n * Performs a depth-first traversal over all of the node descendants,\n * incrementing currentIndex by 1 for each\n */\n\nfunction getNodeDataAtTreeIndexOrNextIndex(_ref) {\n  var targetIndex = _ref.targetIndex,\n      node = _ref.node,\n      currentIndex = _ref.currentIndex,\n      getNodeKey = _ref.getNodeKey,\n      _ref$path = _ref.path,\n      path = _ref$path === void 0 ? [] : _ref$path,\n      _ref$lowerSiblingCoun = _ref.lowerSiblingCounts,\n      lowerSiblingCounts = _ref$lowerSiblingCoun === void 0 ? [] : _ref$lowerSiblingCoun,\n      _ref$ignoreCollapsed = _ref.ignoreCollapsed,\n      ignoreCollapsed = _ref$ignoreCollapsed === void 0 ? true : _ref$ignoreCollapsed,\n      _ref$isPseudoRoot = _ref.isPseudoRoot,\n      isPseudoRoot = _ref$isPseudoRoot === void 0 ? false : _ref$isPseudoRoot; // The pseudo-root is not considered in the path\n\n  var selfPath = !isPseudoRoot ? _toConsumableArray(path).concat([getNodeKey({\n    node: node,\n    treeIndex: currentIndex\n  })]) : []; // Return target node when found\n\n  if (currentIndex === targetIndex) {\n    return {\n      node: node,\n      lowerSiblingCounts: lowerSiblingCounts,\n      path: selfPath\n    };\n  } // Add one and continue for nodes with no children or hidden children\n\n\n  if (!node.children || ignoreCollapsed && node.expanded !== true) {\n    return {\n      nextIndex: currentIndex + 1\n    };\n  } // Iterate over each child and their descendants and return the\n  // target node if childIndex reaches the targetIndex\n\n\n  var childIndex = currentIndex + 1;\n  var childCount = node.children.length;\n\n  for (var i = 0; i < childCount; i += 1) {\n    var result = getNodeDataAtTreeIndexOrNextIndex({\n      ignoreCollapsed: ignoreCollapsed,\n      getNodeKey: getNodeKey,\n      targetIndex: targetIndex,\n      node: node.children[i],\n      currentIndex: childIndex,\n      lowerSiblingCounts: _toConsumableArray(lowerSiblingCounts).concat([childCount - i - 1]),\n      path: selfPath\n    });\n\n    if (result.node) {\n      return result;\n    }\n\n    childIndex = result.nextIndex;\n  } // If the target node is not found, return the farthest traversed index\n\n\n  return {\n    nextIndex: childIndex\n  };\n}\n\nfunction getDescendantCount(_ref2) {\n  var node = _ref2.node,\n      _ref2$ignoreCollapsed = _ref2.ignoreCollapsed,\n      ignoreCollapsed = _ref2$ignoreCollapsed === void 0 ? true : _ref2$ignoreCollapsed;\n  return getNodeDataAtTreeIndexOrNextIndex({\n    getNodeKey: function getNodeKey() {},\n    ignoreCollapsed: ignoreCollapsed,\n    node: node,\n    currentIndex: 0,\n    targetIndex: -1\n  }).nextIndex - 1;\n}\n/**\n * Walk all descendants of the given node, depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */\n\n\nfunction walkDescendants(_ref3) {\n  var callback = _ref3.callback,\n      getNodeKey = _ref3.getNodeKey,\n      ignoreCollapsed = _ref3.ignoreCollapsed,\n      _ref3$isPseudoRoot = _ref3.isPseudoRoot,\n      isPseudoRoot = _ref3$isPseudoRoot === void 0 ? false : _ref3$isPseudoRoot,\n      node = _ref3.node,\n      _ref3$parentNode = _ref3.parentNode,\n      parentNode = _ref3$parentNode === void 0 ? null : _ref3$parentNode,\n      currentIndex = _ref3.currentIndex,\n      _ref3$path = _ref3.path,\n      path = _ref3$path === void 0 ? [] : _ref3$path,\n      _ref3$lowerSiblingCou = _ref3.lowerSiblingCounts,\n      lowerSiblingCounts = _ref3$lowerSiblingCou === void 0 ? [] : _ref3$lowerSiblingCou; // The pseudo-root is not considered in the path\n\n  var selfPath = isPseudoRoot ? [] : _toConsumableArray(path).concat([getNodeKey({\n    node: node,\n    treeIndex: currentIndex\n  })]);\n  var selfInfo = isPseudoRoot ? null : {\n    node: node,\n    parentNode: parentNode,\n    path: selfPath,\n    lowerSiblingCounts: lowerSiblingCounts,\n    treeIndex: currentIndex\n  };\n\n  if (!isPseudoRoot) {\n    var callbackResult = callback(selfInfo); // Cut walk short if the callback returned false\n\n    if (callbackResult === false) {\n      return false;\n    }\n  } // Return self on nodes with no children or hidden children\n\n\n  if (!node.children || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n    return currentIndex;\n  } // Get all descendants\n\n\n  var childIndex = currentIndex;\n  var childCount = node.children.length;\n\n  if (typeof node.children !== 'function') {\n    for (var i = 0; i < childCount; i += 1) {\n      childIndex = walkDescendants({\n        callback: callback,\n        getNodeKey: getNodeKey,\n        ignoreCollapsed: ignoreCollapsed,\n        node: node.children[i],\n        parentNode: isPseudoRoot ? null : node,\n        currentIndex: childIndex + 1,\n        lowerSiblingCounts: _toConsumableArray(lowerSiblingCounts).concat([childCount - i - 1]),\n        path: selfPath\n      }); // Cut walk short if the callback returned false\n\n      if (childIndex === false) {\n        return false;\n      }\n    }\n  }\n\n  return childIndex;\n}\n/**\n * Perform a change on the given node and all its descendants, traversing the tree depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */\n\n\nfunction mapDescendants(_ref4) {\n  var callback = _ref4.callback,\n      getNodeKey = _ref4.getNodeKey,\n      ignoreCollapsed = _ref4.ignoreCollapsed,\n      _ref4$isPseudoRoot = _ref4.isPseudoRoot,\n      isPseudoRoot = _ref4$isPseudoRoot === void 0 ? false : _ref4$isPseudoRoot,\n      node = _ref4.node,\n      _ref4$parentNode = _ref4.parentNode,\n      parentNode = _ref4$parentNode === void 0 ? null : _ref4$parentNode,\n      currentIndex = _ref4.currentIndex,\n      _ref4$path = _ref4.path,\n      path = _ref4$path === void 0 ? [] : _ref4$path,\n      _ref4$lowerSiblingCou = _ref4.lowerSiblingCounts,\n      lowerSiblingCounts = _ref4$lowerSiblingCou === void 0 ? [] : _ref4$lowerSiblingCou;\n\n  var nextNode = _objectSpread({}, node); // The pseudo-root is not considered in the path\n\n\n  var selfPath = isPseudoRoot ? [] : _toConsumableArray(path).concat([getNodeKey({\n    node: nextNode,\n    treeIndex: currentIndex\n  })]);\n  var selfInfo = {\n    node: nextNode,\n    parentNode: parentNode,\n    path: selfPath,\n    lowerSiblingCounts: lowerSiblingCounts,\n    treeIndex: currentIndex\n  }; // Return self on nodes with no children or hidden children\n\n  if (!nextNode.children || nextNode.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n    return {\n      treeIndex: currentIndex,\n      node: callback(selfInfo)\n    };\n  } // Get all descendants\n\n\n  var childIndex = currentIndex;\n  var childCount = nextNode.children.length;\n\n  if (typeof nextNode.children !== 'function') {\n    nextNode.children = nextNode.children.map(function (child, i) {\n      var mapResult = mapDescendants({\n        callback: callback,\n        getNodeKey: getNodeKey,\n        ignoreCollapsed: ignoreCollapsed,\n        node: child,\n        parentNode: isPseudoRoot ? null : nextNode,\n        currentIndex: childIndex + 1,\n        lowerSiblingCounts: _toConsumableArray(lowerSiblingCounts).concat([childCount - i - 1]),\n        path: selfPath\n      });\n      childIndex = mapResult.treeIndex;\n      return mapResult.node;\n    });\n  }\n\n  return {\n    node: callback(selfInfo),\n    treeIndex: childIndex\n  };\n}\n/**\n * Count all the visible (expanded) descendants in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n *\n * @return {number} count\n */\n\n\nfunction getVisibleNodeCount(_ref5) {\n  var treeData = _ref5.treeData;\n\n  var traverse = function traverse(node) {\n    if (!node.children || node.expanded !== true || typeof node.children === 'function') {\n      return 1;\n    }\n\n    return 1 + node.children.reduce(function (total, currentNode) {\n      return total + traverse(currentNode);\n    }, 0);\n  };\n\n  return treeData.reduce(function (total, currentNode) {\n    return total + traverse(currentNode);\n  }, 0);\n}\n/**\n * Get the <targetIndex>th visible node in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} targetIndex - The index of the node to search for\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }|null} node - The node at targetIndex, or null if not found\n */\n\n\nfunction getVisibleNodeInfoAtIndex(_ref6) {\n  var treeData = _ref6.treeData,\n      targetIndex = _ref6.index,\n      getNodeKey = _ref6.getNodeKey;\n\n  if (!treeData || treeData.length < 1) {\n    return null;\n  } // Call the tree traversal with a pseudo-root node\n\n\n  var result = getNodeDataAtTreeIndexOrNextIndex({\n    targetIndex: targetIndex,\n    getNodeKey: getNodeKey,\n    node: {\n      children: treeData,\n      expanded: true\n    },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: [],\n    isPseudoRoot: true\n  });\n\n  if (result.node) {\n    return result;\n  }\n\n  return null;\n}\n/**\n * Walk descendants depth-first and call a callback on each\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return void\n */\n\n\nfunction walk(_ref7) {\n  var treeData = _ref7.treeData,\n      getNodeKey = _ref7.getNodeKey,\n      callback = _ref7.callback,\n      _ref7$ignoreCollapsed = _ref7.ignoreCollapsed,\n      ignoreCollapsed = _ref7$ignoreCollapsed === void 0 ? true : _ref7$ignoreCollapsed;\n\n  if (!treeData || treeData.length < 1) {\n    return;\n  }\n\n  walkDescendants({\n    callback: callback,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    isPseudoRoot: true,\n    node: {\n      children: treeData\n    },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: []\n  });\n}\n/**\n * Perform a depth-first transversal of the descendants and\n *  make a change to every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\n\n\nfunction map(_ref8) {\n  var treeData = _ref8.treeData,\n      getNodeKey = _ref8.getNodeKey,\n      callback = _ref8.callback,\n      _ref8$ignoreCollapsed = _ref8.ignoreCollapsed,\n      ignoreCollapsed = _ref8$ignoreCollapsed === void 0 ? true : _ref8$ignoreCollapsed;\n\n  if (!treeData || treeData.length < 1) {\n    return [];\n  }\n\n  return mapDescendants({\n    callback: callback,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    isPseudoRoot: true,\n    node: {\n      children: treeData\n    },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: []\n  }).node.children;\n}\n/**\n * Expand or close every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {?boolean} expanded - Whether the node is expanded or not\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\n\n\nfunction toggleExpandedForAll(_ref9) {\n  var treeData = _ref9.treeData,\n      _ref9$expanded = _ref9.expanded,\n      expanded = _ref9$expanded === void 0 ? true : _ref9$expanded;\n  return map({\n    treeData: treeData,\n    callback: function callback(_ref10) {\n      var node = _ref10.node;\n      return _objectSpread({}, node, {\n        expanded: expanded\n      });\n    },\n    getNodeKey: function getNodeKey(_ref11) {\n      var treeIndex = _ref11.treeIndex;\n      return treeIndex;\n    },\n    ignoreCollapsed: false\n  });\n}\n/**\n * Replaces node at path with object, or callback-defined object\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be changed\n * @param {function|any} newNode - Node to replace the node at the path with, or a function producing the new node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\n\n\nfunction changeNodeAtPath(_ref12) {\n  var treeData = _ref12.treeData,\n      path = _ref12.path,\n      newNode = _ref12.newNode,\n      getNodeKey = _ref12.getNodeKey,\n      _ref12$ignoreCollapse = _ref12.ignoreCollapsed,\n      ignoreCollapsed = _ref12$ignoreCollapse === void 0 ? true : _ref12$ignoreCollapse;\n  var RESULT_MISS = 'RESULT_MISS';\n\n  var traverse = function traverse(_ref13) {\n    var _ref13$isPseudoRoot = _ref13.isPseudoRoot,\n        isPseudoRoot = _ref13$isPseudoRoot === void 0 ? false : _ref13$isPseudoRoot,\n        node = _ref13.node,\n        currentTreeIndex = _ref13.currentTreeIndex,\n        pathIndex = _ref13.pathIndex;\n\n    if (!isPseudoRoot && getNodeKey({\n      node: node,\n      treeIndex: currentTreeIndex\n    }) !== path[pathIndex]) {\n      return RESULT_MISS;\n    }\n\n    if (pathIndex >= path.length - 1) {\n      // If this is the final location in the path, return its changed form\n      return typeof newNode === 'function' ? newNode({\n        node: node,\n        treeIndex: currentTreeIndex\n      }) : newNode;\n    }\n\n    if (!node.children) {\n      // If this node is part of the path, but has no children, return the unchanged node\n      throw new Error('Path referenced children of node with no children.');\n    }\n\n    var nextTreeIndex = currentTreeIndex + 1;\n\n    for (var i = 0; i < node.children.length; i += 1) {\n      var _result = traverse({\n        node: node.children[i],\n        currentTreeIndex: nextTreeIndex,\n        pathIndex: pathIndex + 1\n      }); // If the result went down the correct path\n\n\n      if (_result !== RESULT_MISS) {\n        if (_result) {\n          // If the result was truthy (in this case, an object),\n          //  pass it to the next level of recursion up\n          return _objectSpread({}, node, {\n            children: _toConsumableArray(node.children.slice(0, i)).concat([_result], _toConsumableArray(node.children.slice(i + 1)))\n          });\n        } // If the result was falsy (returned from the newNode function), then\n        //  delete the node from the array.\n\n\n        return _objectSpread({}, node, {\n          children: _toConsumableArray(node.children.slice(0, i)).concat(_toConsumableArray(node.children.slice(i + 1)))\n        });\n      }\n\n      nextTreeIndex += 1 + getDescendantCount({\n        node: node.children[i],\n        ignoreCollapsed: ignoreCollapsed\n      });\n    }\n\n    return RESULT_MISS;\n  }; // Use a pseudo-root node in the beginning traversal\n\n\n  var result = traverse({\n    node: {\n      children: treeData\n    },\n    currentTreeIndex: -1,\n    pathIndex: -1,\n    isPseudoRoot: true\n  });\n\n  if (result === RESULT_MISS) {\n    throw new Error('No node found at the given path.');\n  }\n\n  return result.children;\n}\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The tree data with the node removed\n */\n\n\nfunction removeNodeAtPath(_ref14) {\n  var treeData = _ref14.treeData,\n      path = _ref14.path,\n      getNodeKey = _ref14.getNodeKey,\n      _ref14$ignoreCollapse = _ref14.ignoreCollapsed,\n      ignoreCollapsed = _ref14$ignoreCollapse === void 0 ? true : _ref14$ignoreCollapse;\n  return changeNodeAtPath({\n    treeData: treeData,\n    path: path,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    newNode: null // Delete the node\n\n  });\n}\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node removed\n * @return {Object} result.node - The node that was removed\n * @return {number} result.treeIndex - The previous treeIndex of the removed node\n */\n\n\nfunction removeNode(_ref15) {\n  var treeData = _ref15.treeData,\n      path = _ref15.path,\n      getNodeKey = _ref15.getNodeKey,\n      _ref15$ignoreCollapse = _ref15.ignoreCollapsed,\n      ignoreCollapsed = _ref15$ignoreCollapse === void 0 ? true : _ref15$ignoreCollapse;\n  var removedNode = null;\n  var removedTreeIndex = null;\n  var nextTreeData = changeNodeAtPath({\n    treeData: treeData,\n    path: path,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    newNode: function newNode(_ref16) {\n      var node = _ref16.node,\n          treeIndex = _ref16.treeIndex; // Store the target node and delete it from the tree\n\n      removedNode = node;\n      removedTreeIndex = treeIndex;\n      return null;\n    }\n  });\n  return {\n    treeData: nextTreeData,\n    node: removedNode,\n    treeIndex: removedTreeIndex\n  };\n}\n/**\n * Gets the node at the specified path\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object|null} nodeInfo - The node info at the given path, or null if not found\n */\n\n\nfunction getNodeAtPath(_ref17) {\n  var treeData = _ref17.treeData,\n      path = _ref17.path,\n      getNodeKey = _ref17.getNodeKey,\n      _ref17$ignoreCollapse = _ref17.ignoreCollapsed,\n      ignoreCollapsed = _ref17$ignoreCollapse === void 0 ? true : _ref17$ignoreCollapse;\n  var foundNodeInfo = null;\n\n  try {\n    changeNodeAtPath({\n      treeData: treeData,\n      path: path,\n      getNodeKey: getNodeKey,\n      ignoreCollapsed: ignoreCollapsed,\n      newNode: function newNode(_ref18) {\n        var node = _ref18.node,\n            treeIndex = _ref18.treeIndex;\n        foundNodeInfo = {\n          node: node,\n          treeIndex: treeIndex\n        };\n        return node;\n      }\n    });\n  } catch (err) {// Ignore the error -- the null return will be explanation enough\n  }\n\n  return foundNodeInfo;\n}\n/**\n * Adds the node to the specified parent and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {!Object} newNode - The node to insert\n * @param {number|string} parentKey - The key of the to-be parentNode of the node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parentNode specified by parentPath\n * @param {boolean=} addAsFirstChild - If true, adds new node as first child of tree\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The updated tree data\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n */\n\n\nfunction addNodeUnderParent(_ref19) {\n  var treeData = _ref19.treeData,\n      newNode = _ref19.newNode,\n      _ref19$parentKey = _ref19.parentKey,\n      parentKey = _ref19$parentKey === void 0 ? null : _ref19$parentKey,\n      getNodeKey = _ref19.getNodeKey,\n      _ref19$ignoreCollapse = _ref19.ignoreCollapsed,\n      ignoreCollapsed = _ref19$ignoreCollapse === void 0 ? true : _ref19$ignoreCollapse,\n      _ref19$expandParent = _ref19.expandParent,\n      expandParent = _ref19$expandParent === void 0 ? false : _ref19$expandParent,\n      _ref19$addAsFirstChil = _ref19.addAsFirstChild,\n      addAsFirstChild = _ref19$addAsFirstChil === void 0 ? false : _ref19$addAsFirstChil;\n\n  if (parentKey === null) {\n    return {\n      treeData: _toConsumableArray(treeData || []).concat([newNode]),\n      treeIndex: (treeData || []).length\n    };\n  }\n\n  var insertedTreeIndex = null;\n  var hasBeenAdded = false;\n  var changedTreeData = map({\n    treeData: treeData,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    callback: function callback(_ref20) {\n      var node = _ref20.node,\n          treeIndex = _ref20.treeIndex,\n          path = _ref20.path;\n      var key = path ? path[path.length - 1] : null; // Return nodes that are not the parent as-is\n\n      if (hasBeenAdded || key !== parentKey) {\n        return node;\n      }\n\n      hasBeenAdded = true;\n\n      var parentNode = _objectSpread({}, node);\n\n      if (expandParent) {\n        parentNode.expanded = true;\n      } // If no children exist yet, just add the single newNode\n\n\n      if (!parentNode.children) {\n        insertedTreeIndex = treeIndex + 1;\n        return _objectSpread({}, parentNode, {\n          children: [newNode]\n        });\n      }\n\n      if (typeof parentNode.children === 'function') {\n        throw new Error('Cannot add to children defined by a function');\n      }\n\n      var nextTreeIndex = treeIndex + 1;\n\n      for (var i = 0; i < parentNode.children.length; i += 1) {\n        nextTreeIndex += 1 + getDescendantCount({\n          node: parentNode.children[i],\n          ignoreCollapsed: ignoreCollapsed\n        });\n      }\n\n      insertedTreeIndex = nextTreeIndex;\n      var children = addAsFirstChild ? [newNode].concat(_toConsumableArray(parentNode.children)) : _toConsumableArray(parentNode.children).concat([newNode]);\n      return _objectSpread({}, parentNode, {\n        children: children\n      });\n    }\n  });\n\n  if (!hasBeenAdded) {\n    throw new Error('No node found with the given key.');\n  }\n\n  return {\n    treeData: changedTreeData,\n    treeIndex: insertedTreeIndex\n  };\n}\n\nfunction addNodeAtDepthAndIndex(_ref21) {\n  var targetDepth = _ref21.targetDepth,\n      minimumTreeIndex = _ref21.minimumTreeIndex,\n      newNode = _ref21.newNode,\n      ignoreCollapsed = _ref21.ignoreCollapsed,\n      expandParent = _ref21.expandParent,\n      _ref21$isPseudoRoot = _ref21.isPseudoRoot,\n      isPseudoRoot = _ref21$isPseudoRoot === void 0 ? false : _ref21$isPseudoRoot,\n      isLastChild = _ref21.isLastChild,\n      node = _ref21.node,\n      currentIndex = _ref21.currentIndex,\n      currentDepth = _ref21.currentDepth,\n      getNodeKey = _ref21.getNodeKey,\n      _ref21$path = _ref21.path,\n      path = _ref21$path === void 0 ? [] : _ref21$path;\n\n  var selfPath = function selfPath(n) {\n    return isPseudoRoot ? [] : _toConsumableArray(path).concat([getNodeKey({\n      node: n,\n      treeIndex: currentIndex\n    })]);\n  }; // If the current position is the only possible place to add, add it\n\n\n  if (currentIndex >= minimumTreeIndex - 1 || isLastChild && !(node.children && node.children.length)) {\n    if (typeof node.children === 'function') {\n      throw new Error('Cannot add to children defined by a function');\n    } else {\n      var extraNodeProps = expandParent ? {\n        expanded: true\n      } : {};\n\n      var _nextNode = _objectSpread({}, node, extraNodeProps, {\n        children: node.children ? [newNode].concat(_toConsumableArray(node.children)) : [newNode]\n      });\n\n      return {\n        node: _nextNode,\n        nextIndex: currentIndex + 2,\n        insertedTreeIndex: currentIndex + 1,\n        parentPath: selfPath(_nextNode),\n        parentNode: isPseudoRoot ? null : _nextNode\n      };\n    }\n  } // If this is the target depth for the insertion,\n  // i.e., where the newNode can be added to the current node's children\n\n\n  if (currentDepth >= targetDepth - 1) {\n    // Skip over nodes with no children or hidden children\n    if (!node.children || typeof node.children === 'function' || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n      return {\n        node: node,\n        nextIndex: currentIndex + 1\n      };\n    } // Scan over the children to see if there's a place among them that fulfills\n    // the minimumTreeIndex requirement\n\n\n    var _childIndex = currentIndex + 1;\n\n    var _insertedTreeIndex = null;\n    var insertIndex = null;\n\n    for (var i = 0; i < node.children.length; i += 1) {\n      // If a valid location is found, mark it as the insertion location and\n      // break out of the loop\n      if (_childIndex >= minimumTreeIndex) {\n        _insertedTreeIndex = _childIndex;\n        insertIndex = i;\n        break;\n      } // Increment the index by the child itself plus the number of descendants it has\n\n\n      _childIndex += 1 + getDescendantCount({\n        node: node.children[i],\n        ignoreCollapsed: ignoreCollapsed\n      });\n    } // If no valid indices to add the node were found\n\n\n    if (insertIndex === null) {\n      // If the last position in this node's children is less than the minimum index\n      // and there are more children on the level of this node, return without insertion\n      if (_childIndex < minimumTreeIndex && !isLastChild) {\n        return {\n          node: node,\n          nextIndex: _childIndex\n        };\n      } // Use the last position in the children array to insert the newNode\n\n\n      _insertedTreeIndex = _childIndex;\n      insertIndex = node.children.length;\n    } // Insert the newNode at the insertIndex\n\n\n    var _nextNode2 = _objectSpread({}, node, {\n      children: _toConsumableArray(node.children.slice(0, insertIndex)).concat([newNode], _toConsumableArray(node.children.slice(insertIndex)))\n    }); // Return node with successful insert result\n\n\n    return {\n      node: _nextNode2,\n      nextIndex: _childIndex,\n      insertedTreeIndex: _insertedTreeIndex,\n      parentPath: selfPath(_nextNode2),\n      parentNode: isPseudoRoot ? null : _nextNode2\n    };\n  } // Skip over nodes with no children or hidden children\n\n\n  if (!node.children || typeof node.children === 'function' || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n    return {\n      node: node,\n      nextIndex: currentIndex + 1\n    };\n  } // Get all descendants\n\n\n  var insertedTreeIndex = null;\n  var pathFragment = null;\n  var parentNode = null;\n  var childIndex = currentIndex + 1;\n  var newChildren = node.children;\n\n  if (typeof newChildren !== 'function') {\n    newChildren = newChildren.map(function (child, i) {\n      if (insertedTreeIndex !== null) {\n        return child;\n      }\n\n      var mapResult = addNodeAtDepthAndIndex({\n        targetDepth: targetDepth,\n        minimumTreeIndex: minimumTreeIndex,\n        newNode: newNode,\n        ignoreCollapsed: ignoreCollapsed,\n        expandParent: expandParent,\n        isLastChild: isLastChild && i === newChildren.length - 1,\n        node: child,\n        currentIndex: childIndex,\n        currentDepth: currentDepth + 1,\n        getNodeKey: getNodeKey,\n        path: [] // Cannot determine the parent path until the children have been processed\n\n      });\n\n      if ('insertedTreeIndex' in mapResult) {\n        insertedTreeIndex = mapResult.insertedTreeIndex;\n        parentNode = mapResult.parentNode;\n        pathFragment = mapResult.parentPath;\n      }\n\n      childIndex = mapResult.nextIndex;\n      return mapResult.node;\n    });\n  }\n\n  var nextNode = _objectSpread({}, node, {\n    children: newChildren\n  });\n\n  var result = {\n    node: nextNode,\n    nextIndex: childIndex\n  };\n\n  if (insertedTreeIndex !== null) {\n    result.insertedTreeIndex = insertedTreeIndex;\n    result.parentPath = _toConsumableArray(selfPath(nextNode)).concat(_toConsumableArray(pathFragment));\n    result.parentNode = parentNode;\n  }\n\n  return result;\n}\n/**\n * Insert a node into the tree at the given depth, after the minimum index\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} depth - The depth to insert the node at (the first level of the array being depth 0)\n * @param {!number} minimumTreeIndex - The lowest possible treeIndex to insert the node at\n * @param {!Object} newNode - The node to insert into the tree\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parent of the inserted node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node added\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n * @return {number[]|string[]} result.path - Array of keys leading to the node location after insertion\n * @return {Object} result.parentNode - The parent node of the inserted node\n */\n\n\nfunction insertNode(_ref22) {\n  var treeData = _ref22.treeData,\n      targetDepth = _ref22.depth,\n      minimumTreeIndex = _ref22.minimumTreeIndex,\n      newNode = _ref22.newNode,\n      _ref22$getNodeKey = _ref22.getNodeKey,\n      getNodeKey = _ref22$getNodeKey === void 0 ? function () {} : _ref22$getNodeKey,\n      _ref22$ignoreCollapse = _ref22.ignoreCollapsed,\n      ignoreCollapsed = _ref22$ignoreCollapse === void 0 ? true : _ref22$ignoreCollapse,\n      _ref22$expandParent = _ref22.expandParent,\n      expandParent = _ref22$expandParent === void 0 ? false : _ref22$expandParent;\n\n  if (!treeData && targetDepth === 0) {\n    return {\n      treeData: [newNode],\n      treeIndex: 0,\n      path: [getNodeKey({\n        node: newNode,\n        treeIndex: 0\n      })],\n      parentNode: null\n    };\n  }\n\n  var insertResult = addNodeAtDepthAndIndex({\n    targetDepth: targetDepth,\n    minimumTreeIndex: minimumTreeIndex,\n    newNode: newNode,\n    ignoreCollapsed: ignoreCollapsed,\n    expandParent: expandParent,\n    getNodeKey: getNodeKey,\n    isPseudoRoot: true,\n    isLastChild: true,\n    node: {\n      children: treeData\n    },\n    currentIndex: -1,\n    currentDepth: -1\n  });\n\n  if (!('insertedTreeIndex' in insertResult)) {\n    throw new Error('No suitable position found to insert.');\n  }\n\n  var treeIndex = insertResult.insertedTreeIndex;\n  return {\n    treeData: insertResult.node.children,\n    treeIndex: treeIndex,\n    path: _toConsumableArray(insertResult.parentPath).concat([getNodeKey({\n      node: newNode,\n      treeIndex: treeIndex\n    })]),\n    parentNode: insertResult.parentNode\n  };\n}\n/**\n * Get tree data flattened.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }}[] nodes - The node array\n */\n\n\nfunction getFlatDataFromTree(_ref23) {\n  var treeData = _ref23.treeData,\n      getNodeKey = _ref23.getNodeKey,\n      _ref23$ignoreCollapse = _ref23.ignoreCollapsed,\n      ignoreCollapsed = _ref23$ignoreCollapse === void 0 ? true : _ref23$ignoreCollapse;\n\n  if (!treeData || treeData.length < 1) {\n    return [];\n  }\n\n  var flattened = [];\n  walk({\n    treeData: treeData,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    callback: function callback(nodeInfo) {\n      flattened.push(nodeInfo);\n    }\n  });\n  return flattened;\n}\n/**\n * Generate a tree structure from flat data.\n *\n * @param {!Object[]} flatData\n * @param {!function=} getKey - Function to get the key from the nodeData\n * @param {!function=} getParentKey - Function to get the parent key from the nodeData\n * @param {string|number=} rootKey - The value returned by `getParentKey` that corresponds to the root node.\n *                                  For example, if your nodes have id 1-99, you might use rootKey = 0\n *\n * @return {Object[]} treeData - The flat data represented as a tree\n */\n\n\nfunction getTreeFromFlatData(_ref24) {\n  var flatData = _ref24.flatData,\n      _ref24$getKey = _ref24.getKey,\n      getKey = _ref24$getKey === void 0 ? function (node) {\n    return node.id;\n  } : _ref24$getKey,\n      _ref24$getParentKey = _ref24.getParentKey,\n      getParentKey = _ref24$getParentKey === void 0 ? function (node) {\n    return node.parentId;\n  } : _ref24$getParentKey,\n      _ref24$rootKey = _ref24.rootKey,\n      rootKey = _ref24$rootKey === void 0 ? '0' : _ref24$rootKey;\n\n  if (!flatData) {\n    return [];\n  }\n\n  var childrenToParents = {};\n  flatData.forEach(function (child) {\n    var parentKey = getParentKey(child);\n\n    if (parentKey in childrenToParents) {\n      childrenToParents[parentKey].push(child);\n    } else {\n      childrenToParents[parentKey] = [child];\n    }\n  });\n\n  if (!(rootKey in childrenToParents)) {\n    return [];\n  }\n\n  var trav = function trav(parent) {\n    var parentKey = getKey(parent);\n\n    if (parentKey in childrenToParents) {\n      return _objectSpread({}, parent, {\n        children: childrenToParents[parentKey].map(function (child) {\n          return trav(child);\n        })\n      });\n    }\n\n    return _objectSpread({}, parent);\n  };\n\n  return childrenToParents[rootKey].map(function (child) {\n    return trav(child);\n  });\n}\n/**\n * Check if a node is a descendant of another node.\n *\n * @param {!Object} older - Potential ancestor of younger node\n * @param {!Object} younger - Potential descendant of older node\n *\n * @return {boolean}\n */\n\n\nfunction isDescendant(older, younger) {\n  return !!older.children && typeof older.children !== 'function' && older.children.some(function (child) {\n    return child === younger || isDescendant(child, younger);\n  });\n}\n/**\n * Get the maximum depth of the children (the depth of the root node is 0).\n *\n * @param {!Object} node - Node in the tree\n * @param {?number} depth - The current depth\n *\n * @return {number} maxDepth - The deepest depth in the tree\n */\n\n\nfunction getDepth(node) {\n  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  if (!node.children) {\n    return depth;\n  }\n\n  if (typeof node.children === 'function') {\n    return depth + 1;\n  }\n\n  return node.children.reduce(function (deepest, child) {\n    return Math.max(deepest, getDepth(child, depth + 1));\n  }, depth);\n}\n/**\n * Find nodes matching a search query in the tree,\n *\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {!Object[]} treeData - Tree data\n * @param {?string|number} searchQuery - Function returning a boolean to indicate whether the node is a match or not\n * @param {!function} searchMethod - Function returning a boolean to indicate whether the node is a match or not\n * @param {?number} searchFocusOffset - The offset of the match to focus on\n *                                      (e.g., 0 focuses on the first match, 1 on the second)\n * @param {boolean=} expandAllMatchPaths - If true, expands the paths to any matched node\n * @param {boolean=} expandFocusMatchPaths - If true, expands the path to the focused node\n *\n * @return {Object[]} matches - An array of objects containing the matching `node`s, their `path`s and `treeIndex`s\n * @return {Object[]} treeData - The original tree data with all relevant nodes expanded.\n *                               If expandAllMatchPaths and expandFocusMatchPaths are both false,\n *                               it will be the same as the original tree data.\n */\n\n\nfunction find(_ref25) {\n  var getNodeKey = _ref25.getNodeKey,\n      treeData = _ref25.treeData,\n      searchQuery = _ref25.searchQuery,\n      searchMethod = _ref25.searchMethod,\n      searchFocusOffset = _ref25.searchFocusOffset,\n      _ref25$expandAllMatch = _ref25.expandAllMatchPaths,\n      expandAllMatchPaths = _ref25$expandAllMatch === void 0 ? false : _ref25$expandAllMatch,\n      _ref25$expandFocusMat = _ref25.expandFocusMatchPaths,\n      expandFocusMatchPaths = _ref25$expandFocusMat === void 0 ? true : _ref25$expandFocusMat;\n  var matchCount = 0;\n\n  var trav = function trav(_ref26) {\n    var _ref26$isPseudoRoot = _ref26.isPseudoRoot,\n        isPseudoRoot = _ref26$isPseudoRoot === void 0 ? false : _ref26$isPseudoRoot,\n        node = _ref26.node,\n        currentIndex = _ref26.currentIndex,\n        _ref26$path = _ref26.path,\n        path = _ref26$path === void 0 ? [] : _ref26$path;\n    var matches = [];\n    var isSelfMatch = false;\n    var hasFocusMatch = false; // The pseudo-root is not considered in the path\n\n    var selfPath = isPseudoRoot ? [] : _toConsumableArray(path).concat([getNodeKey({\n      node: node,\n      treeIndex: currentIndex\n    })]);\n    var extraInfo = isPseudoRoot ? null : {\n      path: selfPath,\n      treeIndex: currentIndex\n    }; // Nodes with with children that aren't lazy\n\n    var hasChildren = node.children && typeof node.children !== 'function' && node.children.length > 0; // Examine the current node to see if it is a match\n\n    if (!isPseudoRoot && searchMethod(_objectSpread({}, extraInfo, {\n      node: node,\n      searchQuery: searchQuery\n    }))) {\n      if (matchCount === searchFocusOffset) {\n        hasFocusMatch = true;\n      } // Keep track of the number of matching nodes, so we know when the searchFocusOffset\n      //  is reached\n\n\n      matchCount += 1; // We cannot add this node to the matches right away, as it may be changed\n      //  during the search of the descendants. The entire node is used in\n      //  comparisons between nodes inside the `matches` and `treeData` results\n      //  of this method (`find`)\n\n      isSelfMatch = true;\n    }\n\n    var childIndex = currentIndex;\n\n    var newNode = _objectSpread({}, node);\n\n    if (hasChildren) {\n      // Get all descendants\n      newNode.children = newNode.children.map(function (child) {\n        var mapResult = trav({\n          node: child,\n          currentIndex: childIndex + 1,\n          path: selfPath\n        }); // Ignore hidden nodes by only advancing the index counter to the returned treeIndex\n        // if the child is expanded.\n        //\n        // The child could have been expanded from the start,\n        // or expanded due to a matching node being found in its descendants\n\n        if (mapResult.node.expanded) {\n          childIndex = mapResult.treeIndex;\n        } else {\n          childIndex += 1;\n        }\n\n        if (mapResult.matches.length > 0 || mapResult.hasFocusMatch) {\n          matches = _toConsumableArray(matches).concat(_toConsumableArray(mapResult.matches));\n\n          if (mapResult.hasFocusMatch) {\n            hasFocusMatch = true;\n          } // Expand the current node if it has descendants matching the search\n          // and the settings are set to do so.\n\n\n          if (expandAllMatchPaths && mapResult.matches.length > 0 || (expandAllMatchPaths || expandFocusMatchPaths) && mapResult.hasFocusMatch) {\n            newNode.expanded = true;\n          }\n        }\n\n        return mapResult.node;\n      });\n    } // Cannot assign a treeIndex to hidden nodes\n\n\n    if (!isPseudoRoot && !newNode.expanded) {\n      matches = matches.map(function (match) {\n        return _objectSpread({}, match, {\n          treeIndex: null\n        });\n      });\n    } // Add this node to the matches if it fits the search criteria.\n    // This is performed at the last minute so newNode can be sent in its final form.\n\n\n    if (isSelfMatch) {\n      matches = [_objectSpread({}, extraInfo, {\n        node: newNode\n      })].concat(_toConsumableArray(matches));\n    }\n\n    return {\n      node: matches.length > 0 ? newNode : node,\n      matches: matches,\n      hasFocusMatch: hasFocusMatch,\n      treeIndex: childIndex\n    };\n  };\n\n  var result = trav({\n    node: {\n      children: treeData\n    },\n    isPseudoRoot: true,\n    currentIndex: -1\n  });\n  return {\n    matches: result.matches,\n    treeData: result.node.children\n  };\n}\n\nvar NodeRendererDefault =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(NodeRendererDefault, _Component);\n\n  function NodeRendererDefault() {\n    _classCallCheck(this, NodeRendererDefault);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(NodeRendererDefault).apply(this, arguments));\n  }\n\n  _createClass(NodeRendererDefault, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          scaffoldBlockPxWidth = _this$props.scaffoldBlockPxWidth,\n          toggleChildrenVisibility = _this$props.toggleChildrenVisibility,\n          connectDragPreview = _this$props.connectDragPreview,\n          connectDragSource = _this$props.connectDragSource,\n          isDragging = _this$props.isDragging,\n          canDrop = _this$props.canDrop,\n          canDrag = _this$props.canDrag,\n          node = _this$props.node,\n          title = _this$props.title,\n          subtitle = _this$props.subtitle,\n          draggedNode = _this$props.draggedNode,\n          path = _this$props.path,\n          treeIndex = _this$props.treeIndex,\n          isSearchMatch = _this$props.isSearchMatch,\n          isSearchFocus = _this$props.isSearchFocus,\n          buttons = _this$props.buttons,\n          className = _this$props.className,\n          style = _this$props.style,\n          didDrop = _this$props.didDrop,\n          treeId = _this$props.treeId,\n          isOver = _this$props.isOver,\n          parentNode = _this$props.parentNode,\n          rowDirection = _this$props.rowDirection,\n          otherProps = _objectWithoutProperties(_this$props, [\"scaffoldBlockPxWidth\", \"toggleChildrenVisibility\", \"connectDragPreview\", \"connectDragSource\", \"isDragging\", \"canDrop\", \"canDrag\", \"node\", \"title\", \"subtitle\", \"draggedNode\", \"path\", \"treeIndex\", \"isSearchMatch\", \"isSearchFocus\", \"buttons\", \"className\", \"style\", \"didDrop\", \"treeId\", \"isOver\", \"parentNode\", \"rowDirection\"]);\n\n      var nodeTitle = title || node.title;\n      var nodeSubtitle = subtitle || node.subtitle;\n      var rowDirectionClass = rowDirection === 'rtl' ? 'rst__rtl' : null;\n      var handle;\n\n      if (canDrag) {\n        if (typeof node.children === 'function' && node.expanded) {\n          // Show a loading symbol on the handle when the children are expanded\n          //  and yet still defined by a function (a callback to fetch the children)\n          handle = React.createElement(\"div\", {\n            className: \"rst__loadingHandle\"\n          }, React.createElement(\"div\", {\n            className: \"rst__loadingCircle\"\n          }, _toConsumableArray(new Array(12)).map(function (_, index) {\n            return React.createElement(\"div\", {\n              // eslint-disable-next-line react/no-array-index-key\n              key: index,\n              className: classnames('rst__loadingCirclePoint', rowDirectionClass)\n            });\n          })));\n        } else {\n          // Show the handle used to initiate a drag-and-drop\n          handle = connectDragSource(React.createElement(\"div\", {\n            className: \"rst__moveHandle\"\n          }), {\n            dropEffect: 'copy'\n          });\n        }\n      }\n\n      var isDraggedDescendant = draggedNode && isDescendant(draggedNode, node);\n      var isLandingPadActive = !didDrop && isDragging;\n      var buttonStyle = {\n        left: -0.5 * scaffoldBlockPxWidth\n      };\n\n      if (rowDirection === 'rtl') {\n        buttonStyle = {\n          right: -0.5 * scaffoldBlockPxWidth\n        };\n      }\n\n      return React.createElement(\"div\", _extends({\n        style: {\n          height: '100%'\n        }\n      }, otherProps), toggleChildrenVisibility && node.children && (node.children.length > 0 || typeof node.children === 'function') && React.createElement(\"div\", null, React.createElement(\"button\", {\n        type: \"button\",\n        \"aria-label\": node.expanded ? 'Collapse' : 'Expand',\n        className: classnames(node.expanded ? 'rst__collapseButton' : 'rst__expandButton', rowDirectionClass),\n        style: buttonStyle,\n        onClick: function onClick() {\n          return toggleChildrenVisibility({\n            node: node,\n            path: path,\n            treeIndex: treeIndex\n          });\n        }\n      }), node.expanded && !isDragging && React.createElement(\"div\", {\n        style: {\n          width: scaffoldBlockPxWidth\n        },\n        className: classnames('rst__lineChildren', rowDirectionClass)\n      })), React.createElement(\"div\", {\n        className: classnames('rst__rowWrapper', rowDirectionClass)\n      }, connectDragPreview(React.createElement(\"div\", {\n        className: classnames('rst__row', isLandingPadActive && 'rst__rowLandingPad', isLandingPadActive && !canDrop && 'rst__rowCancelPad', isSearchMatch && 'rst__rowSearchMatch', isSearchFocus && 'rst__rowSearchFocus', rowDirectionClass, className),\n        style: _objectSpread({\n          opacity: isDraggedDescendant ? 0.5 : 1\n        }, style)\n      }, handle, React.createElement(\"div\", {\n        className: classnames('rst__rowContents', !canDrag && 'rst__rowContentsDragDisabled', rowDirectionClass)\n      }, React.createElement(\"div\", {\n        className: classnames('rst__rowLabel', rowDirectionClass)\n      }, React.createElement(\"span\", {\n        className: classnames('rst__rowTitle', node.subtitle && 'rst__rowTitleWithSubtitle')\n      }, typeof nodeTitle === 'function' ? nodeTitle({\n        node: node,\n        path: path,\n        treeIndex: treeIndex\n      }) : nodeTitle), nodeSubtitle && React.createElement(\"span\", {\n        className: \"rst__rowSubtitle\"\n      }, typeof nodeSubtitle === 'function' ? nodeSubtitle({\n        node: node,\n        path: path,\n        treeIndex: treeIndex\n      }) : nodeSubtitle)), React.createElement(\"div\", {\n        className: \"rst__rowToolbar\"\n      }, buttons.map(function (btn, index) {\n        return React.createElement(\"div\", {\n          key: index // eslint-disable-line react/no-array-index-key\n          ,\n          className: \"rst__toolbarButton\"\n        }, btn);\n      })))))));\n    }\n  }]);\n\n  return NodeRendererDefault;\n}(Component);\n\nNodeRendererDefault.defaultProps = {\n  isSearchMatch: false,\n  isSearchFocus: false,\n  canDrag: false,\n  toggleChildrenVisibility: null,\n  buttons: [],\n  className: '',\n  style: {},\n  parentNode: null,\n  draggedNode: null,\n  canDrop: false,\n  title: null,\n  subtitle: null,\n  rowDirection: 'ltr'\n};\nNodeRendererDefault.propTypes = {\n  node: PropTypes.shape({}).isRequired,\n  title: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),\n  subtitle: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),\n  path: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number])).isRequired,\n  treeIndex: PropTypes.number.isRequired,\n  treeId: PropTypes.string.isRequired,\n  isSearchMatch: PropTypes.bool,\n  isSearchFocus: PropTypes.bool,\n  canDrag: PropTypes.bool,\n  scaffoldBlockPxWidth: PropTypes.number.isRequired,\n  toggleChildrenVisibility: PropTypes.func,\n  buttons: PropTypes.arrayOf(PropTypes.node),\n  className: PropTypes.string,\n  style: PropTypes.shape({}),\n  // Drag and drop API functions\n  // Drag source\n  connectDragPreview: PropTypes.func.isRequired,\n  connectDragSource: PropTypes.func.isRequired,\n  parentNode: PropTypes.shape({}),\n  // Needed for dndManager\n  isDragging: PropTypes.bool.isRequired,\n  didDrop: PropTypes.bool.isRequired,\n  draggedNode: PropTypes.shape({}),\n  // Drop target\n  isOver: PropTypes.bool.isRequired,\n  canDrop: PropTypes.bool,\n  // rtl support\n  rowDirection: PropTypes.string\n};\n\nvar TreePlaceholder =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(TreePlaceholder, _Component);\n\n  function TreePlaceholder() {\n    _classCallCheck(this, TreePlaceholder);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(TreePlaceholder).apply(this, arguments));\n  }\n\n  _createClass(TreePlaceholder, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          children = _this$props.children,\n          connectDropTarget = _this$props.connectDropTarget,\n          treeId = _this$props.treeId,\n          drop = _this$props.drop,\n          otherProps = _objectWithoutProperties(_this$props, [\"children\", \"connectDropTarget\", \"treeId\", \"drop\"]);\n\n      return connectDropTarget(React.createElement(\"div\", null, Children.map(children, function (child) {\n        return cloneElement(child, _objectSpread({}, otherProps));\n      })));\n    }\n  }]);\n\n  return TreePlaceholder;\n}(Component);\n\nTreePlaceholder.defaultProps = {\n  canDrop: false,\n  draggedNode: null\n};\nTreePlaceholder.propTypes = {\n  children: PropTypes.node.isRequired,\n  // Drop target\n  connectDropTarget: PropTypes.func.isRequired,\n  isOver: PropTypes.bool.isRequired,\n  canDrop: PropTypes.bool,\n  draggedNode: PropTypes.shape({}),\n  treeId: PropTypes.string.isRequired,\n  drop: PropTypes.func.isRequired\n};\n\nvar PlaceholderRendererDefault = function PlaceholderRendererDefault(_ref) {\n  var isOver = _ref.isOver,\n      canDrop = _ref.canDrop;\n  return React.createElement(\"div\", {\n    className: classnames('rst__placeholder', canDrop && 'rst__placeholderLandingPad', canDrop && !isOver && 'rst__placeholderCancelPad')\n  });\n};\n\nPlaceholderRendererDefault.defaultProps = {\n  isOver: false,\n  canDrop: false\n};\nPlaceholderRendererDefault.propTypes = {\n  isOver: PropTypes.bool,\n  canDrop: PropTypes.bool\n};\n\nvar memoize = function memoize(f) {\n  var savedArgsArray = [];\n  var savedKeysArray = [];\n  var savedResult = null;\n  return function (args) {\n    var keysArray = Object.keys(args).sort();\n    var argsArray = keysArray.map(function (key) {\n      return args[key];\n    }); // If the arguments for the last insert operation are different than this time,\n    // recalculate the result\n\n    if (argsArray.length !== savedArgsArray.length || argsArray.some(function (arg, index) {\n      return arg !== savedArgsArray[index];\n    }) || keysArray.some(function (key, index) {\n      return key !== savedKeysArray[index];\n    })) {\n      savedArgsArray = argsArray;\n      savedKeysArray = keysArray;\n      savedResult = f(args);\n    }\n\n    return savedResult;\n  };\n};\n\nvar memoizedInsertNode = memoize(insertNode);\nvar memoizedGetFlatDataFromTree = memoize(getFlatDataFromTree);\nvar memoizedGetDescendantCount = memoize(getDescendantCount);\n/* eslint-disable import/prefer-default-export */\n\nfunction slideRows(rows, fromIndex, toIndex) {\n  var count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n  var rowsWithoutMoved = _toConsumableArray(rows.slice(0, fromIndex)).concat(_toConsumableArray(rows.slice(fromIndex + count)));\n\n  return _toConsumableArray(rowsWithoutMoved.slice(0, toIndex)).concat(_toConsumableArray(rows.slice(fromIndex, fromIndex + count)), _toConsumableArray(rowsWithoutMoved.slice(toIndex)));\n}\n\nfunction defaultGetNodeKey(_ref) {\n  var treeIndex = _ref.treeIndex;\n  return treeIndex;\n} // Cheap hack to get the text of a react object\n\n\nfunction getReactElementText(parent) {\n  if (typeof parent === 'string') {\n    return parent;\n  }\n\n  if (_typeof(parent) !== 'object' || !parent.props || !parent.props.children || typeof parent.props.children !== 'string' && _typeof(parent.props.children) !== 'object') {\n    return '';\n  }\n\n  if (typeof parent.props.children === 'string') {\n    return parent.props.children;\n  }\n\n  return parent.props.children.map(function (child) {\n    return getReactElementText(child);\n  }).join('');\n} // Search for a query string inside a node property\n\n\nfunction stringSearch(key, searchQuery, node, path, treeIndex) {\n  if (typeof node[key] === 'function') {\n    // Search within text after calling its function to generate the text\n    return String(node[key]({\n      node: node,\n      path: path,\n      treeIndex: treeIndex\n    })).indexOf(searchQuery) > -1;\n  }\n\n  if (_typeof(node[key]) === 'object') {\n    // Search within text inside react elements\n    return getReactElementText(node[key]).indexOf(searchQuery) > -1;\n  } // Search within string\n\n\n  return node[key] && String(node[key]).indexOf(searchQuery) > -1;\n}\n\nfunction defaultSearchMethod(_ref2) {\n  var node = _ref2.node,\n      path = _ref2.path,\n      treeIndex = _ref2.treeIndex,\n      searchQuery = _ref2.searchQuery;\n  return stringSearch('title', searchQuery, node, path, treeIndex) || stringSearch('subtitle', searchQuery, node, path, treeIndex);\n}\n\nvar DndManager =\n/*#__PURE__*/\nfunction () {\n  function DndManager(treeRef) {\n    _classCallCheck(this, DndManager);\n\n    this.treeRef = treeRef;\n  }\n\n  _createClass(DndManager, [{\n    key: \"getTargetDepth\",\n    value: function getTargetDepth(dropTargetProps, monitor, component) {\n      var dropTargetDepth = 0;\n      var rowAbove = dropTargetProps.getPrevRow();\n\n      if (rowAbove) {\n        var path = rowAbove.path;\n        var aboveNodeCannotHaveChildren = !this.treeRef.canNodeHaveChildren(rowAbove.node);\n\n        if (aboveNodeCannotHaveChildren) {\n          path = path.slice(0, path.length - 1);\n        } // Limit the length of the path to the deepest possible\n\n\n        dropTargetDepth = Math.min(path.length, dropTargetProps.path.length);\n      }\n\n      var blocksOffset;\n      var dragSourceInitialDepth = (monitor.getItem().path || []).length; // When adding node from external source\n\n      if (monitor.getItem().treeId !== this.treeId) {\n        // Ignore the tree depth of the source, if it had any to begin with\n        dragSourceInitialDepth = 0;\n\n        if (component) {\n          var relativePosition = findDOMNode(component).getBoundingClientRect(); // eslint-disable-line react/no-find-dom-node\n\n          var leftShift = monitor.getSourceClientOffset().x - relativePosition.left;\n          blocksOffset = Math.round(leftShift / dropTargetProps.scaffoldBlockPxWidth);\n        } else {\n          blocksOffset = dropTargetProps.path.length;\n        }\n      } else {\n        // handle row direction support\n        var direction = dropTargetProps.rowDirection === 'rtl' ? -1 : 1;\n        blocksOffset = Math.round(direction * monitor.getDifferenceFromInitialOffset().x / dropTargetProps.scaffoldBlockPxWidth);\n      }\n\n      var targetDepth = Math.min(dropTargetDepth, Math.max(0, dragSourceInitialDepth + blocksOffset - 1)); // If a maxDepth is defined, constrain the target depth\n\n      if (typeof this.maxDepth !== 'undefined' && this.maxDepth !== null) {\n        var draggedNode = monitor.getItem().node;\n        var draggedChildDepth = getDepth(draggedNode);\n        targetDepth = Math.max(0, Math.min(targetDepth, this.maxDepth - draggedChildDepth - 1));\n      }\n\n      return targetDepth;\n    }\n  }, {\n    key: \"canDrop\",\n    value: function canDrop(dropTargetProps, monitor) {\n      if (!monitor.isOver()) {\n        return false;\n      }\n\n      var rowAbove = dropTargetProps.getPrevRow();\n      var abovePath = rowAbove ? rowAbove.path : [];\n      var aboveNode = rowAbove ? rowAbove.node : {};\n      var targetDepth = this.getTargetDepth(dropTargetProps, monitor, null); // Cannot drop if we're adding to the children of the row above and\n      //  the row above is a function\n\n      if (targetDepth >= abovePath.length && typeof aboveNode.children === 'function') {\n        return false;\n      }\n\n      if (typeof this.customCanDrop === 'function') {\n        var _monitor$getItem = monitor.getItem(),\n            node = _monitor$getItem.node;\n\n        var addedResult = memoizedInsertNode({\n          treeData: this.treeData,\n          newNode: node,\n          depth: targetDepth,\n          getNodeKey: this.getNodeKey,\n          minimumTreeIndex: dropTargetProps.listIndex,\n          expandParent: true\n        });\n        return this.customCanDrop({\n          node: node,\n          prevPath: monitor.getItem().path,\n          prevParent: monitor.getItem().parentNode,\n          prevTreeIndex: monitor.getItem().treeIndex,\n          // Equals -1 when dragged from external tree\n          nextPath: addedResult.path,\n          nextParent: addedResult.parentNode,\n          nextTreeIndex: addedResult.treeIndex\n        });\n      }\n\n      return true;\n    }\n  }, {\n    key: \"wrapSource\",\n    value: function wrapSource(el) {\n      var _this = this;\n\n      var nodeDragSource = {\n        beginDrag: function beginDrag(props) {\n          _this.startDrag(props);\n\n          return {\n            node: props.node,\n            parentNode: props.parentNode,\n            path: props.path,\n            treeIndex: props.treeIndex,\n            treeId: props.treeId\n          };\n        },\n        endDrag: function endDrag(props, monitor) {\n          _this.endDrag(monitor.getDropResult());\n        },\n        isDragging: function isDragging(props, monitor) {\n          var dropTargetNode = monitor.getItem().node;\n          var draggedNode = props.node;\n          return draggedNode === dropTargetNode;\n        }\n      };\n\n      function nodeDragSourcePropInjection(connect, monitor) {\n        return {\n          connectDragSource: connect.dragSource(),\n          connectDragPreview: connect.dragPreview(),\n          isDragging: monitor.isDragging(),\n          didDrop: monitor.didDrop()\n        };\n      }\n\n      return DragSource(this.dndType, nodeDragSource, nodeDragSourcePropInjection)(el);\n    }\n  }, {\n    key: \"wrapTarget\",\n    value: function wrapTarget(el) {\n      var _this2 = this;\n\n      var nodeDropTarget = {\n        drop: function drop(dropTargetProps, monitor, component) {\n          var result = {\n            node: monitor.getItem().node,\n            path: monitor.getItem().path,\n            treeIndex: monitor.getItem().treeIndex,\n            treeId: _this2.treeId,\n            minimumTreeIndex: dropTargetProps.treeIndex,\n            depth: _this2.getTargetDepth(dropTargetProps, monitor, component)\n          };\n\n          _this2.drop(result);\n\n          return result;\n        },\n        hover: function hover(dropTargetProps, monitor, component) {\n          var targetDepth = _this2.getTargetDepth(dropTargetProps, monitor, component);\n\n          var draggedNode = monitor.getItem().node;\n          var needsRedraw = // Redraw if hovered above different nodes\n          dropTargetProps.node !== draggedNode || // Or hovered above the same node but at a different depth\n          targetDepth !== dropTargetProps.path.length - 1;\n\n          if (!needsRedraw) {\n            return;\n          }\n\n          _this2.dragHover({\n            node: draggedNode,\n            path: monitor.getItem().path,\n            minimumTreeIndex: dropTargetProps.listIndex,\n            depth: targetDepth\n          });\n        },\n        canDrop: this.canDrop.bind(this)\n      };\n\n      function nodeDropTargetPropInjection(connect, monitor) {\n        var dragged = monitor.getItem();\n        return {\n          connectDropTarget: connect.dropTarget(),\n          isOver: monitor.isOver(),\n          canDrop: monitor.canDrop(),\n          draggedNode: dragged ? dragged.node : null\n        };\n      }\n\n      return DropTarget(this.dndType, nodeDropTarget, nodeDropTargetPropInjection)(el);\n    }\n  }, {\n    key: \"wrapPlaceholder\",\n    value: function wrapPlaceholder(el) {\n      var _this3 = this;\n\n      var placeholderDropTarget = {\n        drop: function drop(dropTargetProps, monitor) {\n          var _monitor$getItem2 = monitor.getItem(),\n              node = _monitor$getItem2.node,\n              path = _monitor$getItem2.path,\n              treeIndex = _monitor$getItem2.treeIndex;\n\n          var result = {\n            node: node,\n            path: path,\n            treeIndex: treeIndex,\n            treeId: _this3.treeId,\n            minimumTreeIndex: 0,\n            depth: 0\n          };\n\n          _this3.drop(result);\n\n          return result;\n        }\n      };\n\n      function placeholderPropInjection(connect, monitor) {\n        var dragged = monitor.getItem();\n        return {\n          connectDropTarget: connect.dropTarget(),\n          isOver: monitor.isOver(),\n          canDrop: monitor.canDrop(),\n          draggedNode: dragged ? dragged.node : null\n        };\n      }\n\n      return DropTarget(this.dndType, placeholderDropTarget, placeholderPropInjection)(el);\n    }\n  }, {\n    key: \"startDrag\",\n    get: function get() {\n      return this.treeRef.startDrag;\n    }\n  }, {\n    key: \"dragHover\",\n    get: function get() {\n      return this.treeRef.dragHover;\n    }\n  }, {\n    key: \"endDrag\",\n    get: function get() {\n      return this.treeRef.endDrag;\n    }\n  }, {\n    key: \"drop\",\n    get: function get() {\n      return this.treeRef.drop;\n    }\n  }, {\n    key: \"treeId\",\n    get: function get() {\n      return this.treeRef.treeId;\n    }\n  }, {\n    key: \"dndType\",\n    get: function get() {\n      return this.treeRef.dndType;\n    }\n  }, {\n    key: \"treeData\",\n    get: function get() {\n      return this.treeRef.state.draggingTreeData || this.treeRef.props.treeData;\n    }\n  }, {\n    key: \"getNodeKey\",\n    get: function get() {\n      return this.treeRef.props.getNodeKey;\n    }\n  }, {\n    key: \"customCanDrop\",\n    get: function get() {\n      return this.treeRef.props.canDrop;\n    }\n  }, {\n    key: \"maxDepth\",\n    get: function get() {\n      return this.treeRef.props.maxDepth;\n    }\n  }], [{\n    key: \"wrapRoot\",\n    value: function wrapRoot(el) {\n      return DragDropContext(HTML5Backend)(el);\n    }\n  }]);\n\n  return DndManager;\n}();\n\nvar treeIdCounter = 1;\n\nvar mergeTheme = function mergeTheme(props) {\n  var merged = _objectSpread({}, props, {\n    style: _objectSpread({}, props.theme.style, props.style),\n    innerStyle: _objectSpread({}, props.theme.innerStyle, props.innerStyle),\n    reactVirtualizedListProps: _objectSpread({}, props.theme.reactVirtualizedListProps, props.reactVirtualizedListProps)\n  });\n\n  var overridableDefaults = {\n    nodeContentRenderer: NodeRendererDefault,\n    placeholderRenderer: PlaceholderRendererDefault,\n    rowHeight: 62,\n    scaffoldBlockPxWidth: 44,\n    slideRegionSize: 100,\n    treeNodeRenderer: TreeNode\n  };\n  Object.keys(overridableDefaults).forEach(function (propKey) {\n    // If prop has been specified, do not change it\n    // If prop is specified in theme, use the theme setting\n    // If all else fails, fall back to the default\n    if (props[propKey] === null) {\n      merged[propKey] = typeof props.theme[propKey] !== 'undefined' ? props.theme[propKey] : overridableDefaults[propKey];\n    }\n  });\n  return merged;\n};\n\nvar ReactSortableTree =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(ReactSortableTree, _Component);\n\n  function ReactSortableTree(props) {\n    var _this;\n\n    _classCallCheck(this, ReactSortableTree);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ReactSortableTree).call(this, props));\n\n    var _mergeTheme = mergeTheme(props),\n        dndType = _mergeTheme.dndType,\n        nodeContentRenderer = _mergeTheme.nodeContentRenderer,\n        treeNodeRenderer = _mergeTheme.treeNodeRenderer,\n        isVirtualized = _mergeTheme.isVirtualized,\n        slideRegionSize = _mergeTheme.slideRegionSize;\n\n    _this.dndManager = new DndManager(_assertThisInitialized(_assertThisInitialized(_this))); // Wrapping classes for use with react-dnd\n\n    _this.treeId = \"rst__\".concat(treeIdCounter);\n    treeIdCounter += 1;\n    _this.dndType = dndType || _this.treeId;\n    _this.nodeContentRenderer = _this.dndManager.wrapSource(nodeContentRenderer);\n    _this.treePlaceholderRenderer = _this.dndManager.wrapPlaceholder(TreePlaceholder);\n    _this.treeNodeRenderer = _this.dndManager.wrapTarget(treeNodeRenderer); // Prepare scroll-on-drag options for this list\n\n    if (isVirtualized) {\n      _this.scrollZoneVirtualList = (createScrollingComponent || withScrolling)(List);\n      _this.vStrength = createVerticalStrength(slideRegionSize);\n      _this.hStrength = createHorizontalStrength(slideRegionSize);\n    }\n\n    _this.state = {\n      draggingTreeData: null,\n      draggedNode: null,\n      draggedMinimumTreeIndex: null,\n      draggedDepth: null,\n      searchMatches: [],\n      searchFocusTreeIndex: null,\n      dragging: false,\n      // props that need to be used in gDSFP or static functions will be stored here\n      instanceProps: {\n        treeData: [],\n        ignoreOneTreeUpdate: false,\n        searchQuery: null,\n        searchFocusOffset: null\n      }\n    };\n    _this.toggleChildrenVisibility = _this.toggleChildrenVisibility.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.moveNode = _this.moveNode.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.startDrag = _this.startDrag.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.dragHover = _this.dragHover.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.endDrag = _this.endDrag.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.drop = _this.drop.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.handleDndMonitorChange = _this.handleDndMonitorChange.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  }\n\n  _createClass(ReactSortableTree, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      ReactSortableTree.loadLazyChildren(this.props, this.state);\n      var stateUpdate = ReactSortableTree.search(this.props, this.state, true, true, false);\n      this.setState(stateUpdate); // Hook into react-dnd state changes to detect when the drag ends\n      // TODO: This is very brittle, so it needs to be replaced if react-dnd\n      // offers a more official way to detect when a drag ends\n\n      this.clearMonitorSubscription = this.props.dragDropManager.getMonitor().subscribeToStateChange(this.handleDndMonitorChange);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    // listen to dragging\n    value: function componentDidUpdate(prevProps, prevState) {\n      // if it is not the same then call the onDragStateChanged\n      if (this.state.dragging !== prevState.dragging) {\n        if (this.props.onDragStateChanged) {\n          this.props.onDragStateChanged({\n            isDragging: this.state.dragging,\n            draggedNode: this.state.draggedNode\n          });\n        }\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.clearMonitorSubscription();\n    }\n  }, {\n    key: \"getRows\",\n    value: function getRows(treeData) {\n      return memoizedGetFlatDataFromTree({\n        ignoreCollapsed: true,\n        getNodeKey: this.props.getNodeKey,\n        treeData: treeData\n      });\n    }\n  }, {\n    key: \"handleDndMonitorChange\",\n    value: function handleDndMonitorChange() {\n      var monitor = this.props.dragDropManager.getMonitor(); // If the drag ends and the tree is still in a mid-drag state,\n      // it means that the drag was canceled or the dragSource dropped\n      // elsewhere, and we should reset the state of this tree\n\n      if (!monitor.isDragging() && this.state.draggingTreeData) {\n        this.endDrag();\n      }\n    }\n  }, {\n    key: \"toggleChildrenVisibility\",\n    value: function toggleChildrenVisibility(_ref) {\n      var targetNode = _ref.node,\n          path = _ref.path;\n      var instanceProps = this.state.instanceProps;\n      var treeData = changeNodeAtPath({\n        treeData: instanceProps.treeData,\n        path: path,\n        newNode: function newNode(_ref2) {\n          var node = _ref2.node;\n          return _objectSpread({}, node, {\n            expanded: !node.expanded\n          });\n        },\n        getNodeKey: this.props.getNodeKey\n      });\n      this.props.onChange(treeData);\n      this.props.onVisibilityToggle({\n        treeData: treeData,\n        node: targetNode,\n        expanded: !targetNode.expanded,\n        path: path\n      });\n    }\n  }, {\n    key: \"moveNode\",\n    value: function moveNode(_ref3) {\n      var node = _ref3.node,\n          prevPath = _ref3.path,\n          prevTreeIndex = _ref3.treeIndex,\n          depth = _ref3.depth,\n          minimumTreeIndex = _ref3.minimumTreeIndex;\n\n      var _insertNode = insertNode({\n        treeData: this.state.draggingTreeData,\n        newNode: node,\n        depth: depth,\n        minimumTreeIndex: minimumTreeIndex,\n        expandParent: true,\n        getNodeKey: this.props.getNodeKey\n      }),\n          treeData = _insertNode.treeData,\n          treeIndex = _insertNode.treeIndex,\n          path = _insertNode.path,\n          nextParentNode = _insertNode.parentNode;\n\n      this.props.onChange(treeData);\n      this.props.onMoveNode({\n        treeData: treeData,\n        node: node,\n        treeIndex: treeIndex,\n        path: path,\n        nextPath: path,\n        nextTreeIndex: treeIndex,\n        prevPath: prevPath,\n        prevTreeIndex: prevTreeIndex,\n        nextParentNode: nextParentNode\n      });\n    } // returns the new state after search\n\n  }, {\n    key: \"startDrag\",\n    value: function startDrag(_ref4) {\n      var _this2 = this;\n\n      var path = _ref4.path;\n      this.setState(function (prevState) {\n        var _removeNode = removeNode({\n          treeData: prevState.instanceProps.treeData,\n          path: path,\n          getNodeKey: _this2.props.getNodeKey\n        }),\n            draggingTreeData = _removeNode.treeData,\n            draggedNode = _removeNode.node,\n            draggedMinimumTreeIndex = _removeNode.treeIndex;\n\n        return {\n          draggingTreeData: draggingTreeData,\n          draggedNode: draggedNode,\n          draggedDepth: path.length - 1,\n          draggedMinimumTreeIndex: draggedMinimumTreeIndex,\n          dragging: true\n        };\n      });\n    }\n  }, {\n    key: \"dragHover\",\n    value: function dragHover(_ref5) {\n      var _this3 = this;\n\n      var draggedNode = _ref5.node,\n          draggedDepth = _ref5.depth,\n          draggedMinimumTreeIndex = _ref5.minimumTreeIndex; // Ignore this hover if it is at the same position as the last hover\n\n      if (this.state.draggedDepth === draggedDepth && this.state.draggedMinimumTreeIndex === draggedMinimumTreeIndex) {\n        return;\n      }\n\n      this.setState(function (_ref6) {\n        var draggingTreeData = _ref6.draggingTreeData,\n            instanceProps = _ref6.instanceProps; // Fall back to the tree data if something is being dragged in from\n        //  an external element\n\n        var newDraggingTreeData = draggingTreeData || instanceProps.treeData;\n        var addedResult = memoizedInsertNode({\n          treeData: newDraggingTreeData,\n          newNode: draggedNode,\n          depth: draggedDepth,\n          minimumTreeIndex: draggedMinimumTreeIndex,\n          expandParent: true,\n          getNodeKey: _this3.props.getNodeKey\n        });\n\n        var rows = _this3.getRows(addedResult.treeData);\n\n        var expandedParentPath = rows[addedResult.treeIndex].path;\n        return {\n          draggedNode: draggedNode,\n          draggedDepth: draggedDepth,\n          draggedMinimumTreeIndex: draggedMinimumTreeIndex,\n          draggingTreeData: changeNodeAtPath({\n            treeData: newDraggingTreeData,\n            path: expandedParentPath.slice(0, -1),\n            newNode: function newNode(_ref7) {\n              var node = _ref7.node;\n              return _objectSpread({}, node, {\n                expanded: true\n              });\n            },\n            getNodeKey: _this3.props.getNodeKey\n          }),\n          // reset the scroll focus so it doesn't jump back\n          // to a search result while dragging\n          searchFocusTreeIndex: null,\n          dragging: true\n        };\n      });\n    }\n  }, {\n    key: \"endDrag\",\n    value: function endDrag(dropResult) {\n      var _this4 = this;\n\n      var instanceProps = this.state.instanceProps;\n\n      var resetTree = function resetTree() {\n        return _this4.setState({\n          draggingTreeData: null,\n          draggedNode: null,\n          draggedMinimumTreeIndex: null,\n          draggedDepth: null,\n          dragging: false\n        });\n      }; // Drop was cancelled\n\n\n      if (!dropResult) {\n        resetTree();\n      } else if (dropResult.treeId !== this.treeId) {\n        // The node was dropped in an external drop target or tree\n        var node = dropResult.node,\n            path = dropResult.path,\n            treeIndex = dropResult.treeIndex;\n        var shouldCopy = this.props.shouldCopyOnOutsideDrop;\n\n        if (typeof shouldCopy === 'function') {\n          shouldCopy = shouldCopy({\n            node: node,\n            prevTreeIndex: treeIndex,\n            prevPath: path\n          });\n        }\n\n        var treeData = this.state.draggingTreeData || instanceProps.treeData; // If copying is enabled, a drop outside leaves behind a copy in the\n        //  source tree\n\n        if (shouldCopy) {\n          treeData = changeNodeAtPath({\n            treeData: instanceProps.treeData,\n            // use treeData unaltered by the drag operation\n            path: path,\n            newNode: function newNode(_ref8) {\n              var copyNode = _ref8.node;\n              return _objectSpread({}, copyNode);\n            },\n            // create a shallow copy of the node\n            getNodeKey: this.props.getNodeKey\n          });\n        }\n\n        this.props.onChange(treeData);\n        this.props.onMoveNode({\n          treeData: treeData,\n          node: node,\n          treeIndex: null,\n          path: null,\n          nextPath: null,\n          nextTreeIndex: null,\n          prevPath: path,\n          prevTreeIndex: treeIndex\n        });\n      }\n    }\n  }, {\n    key: \"drop\",\n    value: function drop(dropResult) {\n      this.moveNode(dropResult);\n    }\n  }, {\n    key: \"canNodeHaveChildren\",\n    value: function canNodeHaveChildren(node) {\n      var canNodeHaveChildren = this.props.canNodeHaveChildren;\n\n      if (canNodeHaveChildren) {\n        return canNodeHaveChildren(node);\n      }\n\n      return true;\n    } // Load any children in the tree that are given by a function\n    // calls the onChange callback on the new treeData\n\n  }, {\n    key: \"renderRow\",\n    value: function renderRow(row, _ref9) {\n      var listIndex = _ref9.listIndex,\n          style = _ref9.style,\n          getPrevRow = _ref9.getPrevRow,\n          matchKeys = _ref9.matchKeys,\n          swapFrom = _ref9.swapFrom,\n          swapDepth = _ref9.swapDepth,\n          swapLength = _ref9.swapLength;\n      var node = row.node,\n          parentNode = row.parentNode,\n          path = row.path,\n          lowerSiblingCounts = row.lowerSiblingCounts,\n          treeIndex = row.treeIndex;\n\n      var _mergeTheme2 = mergeTheme(this.props),\n          canDrag = _mergeTheme2.canDrag,\n          generateNodeProps = _mergeTheme2.generateNodeProps,\n          scaffoldBlockPxWidth = _mergeTheme2.scaffoldBlockPxWidth,\n          searchFocusOffset = _mergeTheme2.searchFocusOffset,\n          rowDirection = _mergeTheme2.rowDirection;\n\n      var TreeNodeRenderer = this.treeNodeRenderer;\n      var NodeContentRenderer = this.nodeContentRenderer;\n      var nodeKey = path[path.length - 1];\n      var isSearchMatch = nodeKey in matchKeys;\n      var isSearchFocus = isSearchMatch && matchKeys[nodeKey] === searchFocusOffset;\n      var callbackParams = {\n        node: node,\n        parentNode: parentNode,\n        path: path,\n        lowerSiblingCounts: lowerSiblingCounts,\n        treeIndex: treeIndex,\n        isSearchMatch: isSearchMatch,\n        isSearchFocus: isSearchFocus\n      };\n      var nodeProps = !generateNodeProps ? {} : generateNodeProps(callbackParams);\n      var rowCanDrag = typeof canDrag !== 'function' ? canDrag : canDrag(callbackParams);\n      var sharedProps = {\n        treeIndex: treeIndex,\n        scaffoldBlockPxWidth: scaffoldBlockPxWidth,\n        node: node,\n        path: path,\n        treeId: this.treeId,\n        rowDirection: rowDirection\n      };\n      return React.createElement(TreeNodeRenderer, _extends({\n        style: style,\n        key: nodeKey,\n        listIndex: listIndex,\n        getPrevRow: getPrevRow,\n        lowerSiblingCounts: lowerSiblingCounts,\n        swapFrom: swapFrom,\n        swapLength: swapLength,\n        swapDepth: swapDepth\n      }, sharedProps), React.createElement(NodeContentRenderer, _extends({\n        parentNode: parentNode,\n        isSearchMatch: isSearchMatch,\n        isSearchFocus: isSearchFocus,\n        canDrag: rowCanDrag,\n        toggleChildrenVisibility: this.toggleChildrenVisibility\n      }, sharedProps, nodeProps)));\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this5 = this;\n\n      var _mergeTheme3 = mergeTheme(this.props),\n          dragDropManager = _mergeTheme3.dragDropManager,\n          style = _mergeTheme3.style,\n          className = _mergeTheme3.className,\n          innerStyle = _mergeTheme3.innerStyle,\n          rowHeight = _mergeTheme3.rowHeight,\n          isVirtualized = _mergeTheme3.isVirtualized,\n          placeholderRenderer = _mergeTheme3.placeholderRenderer,\n          reactVirtualizedListProps = _mergeTheme3.reactVirtualizedListProps,\n          getNodeKey = _mergeTheme3.getNodeKey,\n          rowDirection = _mergeTheme3.rowDirection;\n\n      var _this$state = this.state,\n          searchMatches = _this$state.searchMatches,\n          searchFocusTreeIndex = _this$state.searchFocusTreeIndex,\n          draggedNode = _this$state.draggedNode,\n          draggedDepth = _this$state.draggedDepth,\n          draggedMinimumTreeIndex = _this$state.draggedMinimumTreeIndex,\n          instanceProps = _this$state.instanceProps;\n      var treeData = this.state.draggingTreeData || instanceProps.treeData;\n      var rowDirectionClass = rowDirection === 'rtl' ? 'rst__rtl' : null;\n      var rows;\n      var swapFrom = null;\n      var swapLength = null;\n\n      if (draggedNode && draggedMinimumTreeIndex !== null) {\n        var addedResult = memoizedInsertNode({\n          treeData: treeData,\n          newNode: draggedNode,\n          depth: draggedDepth,\n          minimumTreeIndex: draggedMinimumTreeIndex,\n          expandParent: true,\n          getNodeKey: getNodeKey\n        });\n        var swapTo = draggedMinimumTreeIndex;\n        swapFrom = addedResult.treeIndex;\n        swapLength = 1 + memoizedGetDescendantCount({\n          node: draggedNode\n        });\n        rows = slideRows(this.getRows(addedResult.treeData), swapFrom, swapTo, swapLength);\n      } else {\n        rows = this.getRows(treeData);\n      } // Get indices for rows that match the search conditions\n\n\n      var matchKeys = {};\n      searchMatches.forEach(function (_ref10, i) {\n        var path = _ref10.path;\n        matchKeys[path[path.length - 1]] = i;\n      }); // Seek to the focused search result if there is one specified\n\n      var scrollToInfo = searchFocusTreeIndex !== null ? {\n        scrollToIndex: searchFocusTreeIndex\n      } : {};\n      var containerStyle = style;\n      var list;\n\n      if (rows.length < 1) {\n        var Placeholder = this.treePlaceholderRenderer;\n        var PlaceholderContent = placeholderRenderer;\n        list = React.createElement(Placeholder, {\n          treeId: this.treeId,\n          drop: this.drop\n        }, React.createElement(PlaceholderContent, null));\n      } else if (isVirtualized) {\n        containerStyle = _objectSpread({\n          height: '100%'\n        }, containerStyle);\n        var ScrollZoneVirtualList = this.scrollZoneVirtualList; // Render list with react-virtualized\n\n        list = React.createElement(AutoSizer, null, function (_ref11) {\n          var height = _ref11.height,\n              width = _ref11.width;\n          return React.createElement(ScrollZoneVirtualList, _extends({}, scrollToInfo, {\n            dragDropManager: dragDropManager,\n            verticalStrength: _this5.vStrength,\n            horizontalStrength: _this5.hStrength,\n            speed: 30,\n            scrollToAlignment: \"start\",\n            className: \"rst__virtualScrollOverride\",\n            width: width,\n            onScroll: function onScroll(_ref12) {\n              var scrollTop = _ref12.scrollTop;\n              _this5.scrollTop = scrollTop;\n            },\n            height: height,\n            style: innerStyle,\n            rowCount: rows.length,\n            estimatedRowSize: typeof rowHeight !== 'function' ? rowHeight : undefined,\n            rowHeight: typeof rowHeight !== 'function' ? rowHeight : function (_ref13) {\n              var index = _ref13.index;\n              return rowHeight({\n                index: index,\n                treeIndex: index,\n                node: rows[index].node,\n                path: rows[index].path\n              });\n            },\n            rowRenderer: function rowRenderer(_ref14) {\n              var index = _ref14.index,\n                  rowStyle = _ref14.style;\n              return _this5.renderRow(rows[index], {\n                listIndex: index,\n                style: rowStyle,\n                getPrevRow: function getPrevRow() {\n                  return rows[index - 1] || null;\n                },\n                matchKeys: matchKeys,\n                swapFrom: swapFrom,\n                swapDepth: draggedDepth,\n                swapLength: swapLength\n              });\n            }\n          }, reactVirtualizedListProps));\n        });\n      } else {\n        // Render list without react-virtualized\n        list = rows.map(function (row, index) {\n          return _this5.renderRow(row, {\n            listIndex: index,\n            style: {\n              height: typeof rowHeight !== 'function' ? rowHeight : rowHeight({\n                index: index,\n                treeIndex: index,\n                node: row.node,\n                path: row.path\n              })\n            },\n            getPrevRow: function getPrevRow() {\n              return rows[index - 1] || null;\n            },\n            matchKeys: matchKeys,\n            swapFrom: swapFrom,\n            swapDepth: draggedDepth,\n            swapLength: swapLength\n          });\n        });\n      }\n\n      return React.createElement(\"div\", {\n        className: classnames('rst__tree', className, rowDirectionClass),\n        style: containerStyle\n      }, list);\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      var instanceProps = prevState.instanceProps;\n      var newState = {};\n      var isTreeDataEqual = isEqual(instanceProps.treeData, nextProps.treeData); // make sure we have the most recent version of treeData\n\n      instanceProps.treeData = nextProps.treeData;\n\n      if (!isTreeDataEqual) {\n        if (instanceProps.ignoreOneTreeUpdate) {\n          instanceProps.ignoreOneTreeUpdate = false;\n        } else {\n          newState.searchFocusTreeIndex = null;\n          ReactSortableTree.loadLazyChildren(nextProps, prevState);\n          Object.assign(newState, ReactSortableTree.search(nextProps, prevState, false, false, false));\n        }\n\n        newState.draggingTreeData = null;\n        newState.draggedNode = null;\n        newState.draggedMinimumTreeIndex = null;\n        newState.draggedDepth = null;\n        newState.dragging = false;\n      } else if (!isEqual(instanceProps.searchQuery, nextProps.searchQuery)) {\n        Object.assign(newState, ReactSortableTree.search(nextProps, prevState, true, true, false));\n      } else if (instanceProps.searchFocusOffset !== nextProps.searchFocusOffset) {\n        Object.assign(newState, ReactSortableTree.search(nextProps, prevState, true, true, true));\n      }\n\n      instanceProps.searchQuery = nextProps.searchQuery;\n      instanceProps.searchFocusOffset = nextProps.searchFocusOffset;\n      newState.instanceProps = instanceProps;\n      return newState;\n    }\n  }, {\n    key: \"search\",\n    value: function search(props, state, seekIndex, expand, singleSearch) {\n      var onChange = props.onChange,\n          getNodeKey = props.getNodeKey,\n          searchFinishCallback = props.searchFinishCallback,\n          searchQuery = props.searchQuery,\n          searchMethod = props.searchMethod,\n          searchFocusOffset = props.searchFocusOffset,\n          onlyExpandSearchedNodes = props.onlyExpandSearchedNodes;\n      var instanceProps = state.instanceProps; // Skip search if no conditions are specified\n\n      if (!searchQuery && !searchMethod) {\n        if (searchFinishCallback) {\n          searchFinishCallback([]);\n        }\n\n        return {\n          searchMatches: []\n        };\n      }\n\n      var newState = {}; // if onlyExpandSearchedNodes collapse the tree and search\n\n      var _find = find({\n        getNodeKey: getNodeKey,\n        treeData: onlyExpandSearchedNodes ? toggleExpandedForAll({\n          treeData: instanceProps.treeData,\n          expanded: false\n        }) : instanceProps.treeData,\n        searchQuery: searchQuery,\n        searchMethod: searchMethod || defaultSearchMethod,\n        searchFocusOffset: searchFocusOffset,\n        expandAllMatchPaths: expand && !singleSearch,\n        expandFocusMatchPaths: !!expand\n      }),\n          expandedTreeData = _find.treeData,\n          searchMatches = _find.matches; // Update the tree with data leaving all paths leading to matching nodes open\n\n\n      if (expand) {\n        newState.ignoreOneTreeUpdate = true; // Prevents infinite loop\n\n        onChange(expandedTreeData);\n      }\n\n      if (searchFinishCallback) {\n        searchFinishCallback(searchMatches);\n      }\n\n      var searchFocusTreeIndex = null;\n\n      if (seekIndex && searchFocusOffset !== null && searchFocusOffset < searchMatches.length) {\n        searchFocusTreeIndex = searchMatches[searchFocusOffset].treeIndex;\n      }\n\n      newState.searchMatches = searchMatches;\n      newState.searchFocusTreeIndex = searchFocusTreeIndex;\n      return newState;\n    }\n  }, {\n    key: \"loadLazyChildren\",\n    value: function loadLazyChildren(props, state) {\n      var instanceProps = state.instanceProps;\n      walk({\n        treeData: instanceProps.treeData,\n        getNodeKey: props.getNodeKey,\n        callback: function callback(_ref15) {\n          var node = _ref15.node,\n              path = _ref15.path,\n              lowerSiblingCounts = _ref15.lowerSiblingCounts,\n              treeIndex = _ref15.treeIndex; // If the node has children defined by a function, and is either expanded\n          //  or set to load even before expansion, run the function.\n\n          if (node.children && typeof node.children === 'function' && (node.expanded || props.loadCollapsedLazyChildren)) {\n            // Call the children fetching function\n            node.children({\n              node: node,\n              path: path,\n              lowerSiblingCounts: lowerSiblingCounts,\n              treeIndex: treeIndex,\n              // Provide a helper to append the new data when it is received\n              done: function done(childrenArray) {\n                return props.onChange(changeNodeAtPath({\n                  treeData: instanceProps.treeData,\n                  path: path,\n                  newNode: function newNode(_ref16) {\n                    var oldNode = _ref16.node;\n                    return (// Only replace the old node if it's the one we set off to find children\n                      //  for in the first place\n                      oldNode === node ? _objectSpread({}, oldNode, {\n                        children: childrenArray\n                      }) : oldNode\n                    );\n                  },\n                  getNodeKey: props.getNodeKey\n                }));\n              }\n            });\n          }\n        }\n      });\n    }\n  }]);\n\n  return ReactSortableTree;\n}(Component);\n\nReactSortableTree.propTypes = {\n  dragDropManager: PropTypes.shape({}).isRequired,\n  // Tree data in the following format:\n  // [{title: 'main', subtitle: 'sub'}, { title: 'value2', expanded: true, children: [{ title: 'value3') }] }]\n  // `title` is the primary label for the node\n  // `subtitle` is a secondary label for the node\n  // `expanded` shows children of the node if true, or hides them if false. Defaults to false.\n  // `children` is an array of child nodes belonging to the node.\n  treeData: PropTypes.arrayOf(PropTypes.object).isRequired,\n  // Style applied to the container wrapping the tree (style defaults to {height: '100%'})\n  style: PropTypes.shape({}),\n  // Class name for the container wrapping the tree\n  className: PropTypes.string,\n  // Style applied to the inner, scrollable container (for padding, etc.)\n  innerStyle: PropTypes.shape({}),\n  // Used by react-virtualized\n  // Either a fixed row height (number) or a function that returns the\n  // height of a row given its index: `({ index: number }): number`\n  rowHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\n  // Size in px of the region near the edges that initiates scrolling on dragover\n  slideRegionSize: PropTypes.number,\n  // Custom properties to hand to the react-virtualized list\n  // https://github.com/bvaughn/react-virtualized/blob/master/docs/List.md#prop-types\n  reactVirtualizedListProps: PropTypes.shape({}),\n  // The width of the blocks containing the lines representing the structure of the tree.\n  scaffoldBlockPxWidth: PropTypes.number,\n  // Maximum depth nodes can be inserted at. Defaults to infinite.\n  maxDepth: PropTypes.number,\n  // The method used to search nodes.\n  // Defaults to a function that uses the `searchQuery` string to search for nodes with\n  // matching `title` or `subtitle` values.\n  // NOTE: Changing `searchMethod` will not update the search, but changing the `searchQuery` will.\n  searchMethod: PropTypes.func,\n  // Used by the `searchMethod` to highlight and scroll to matched nodes.\n  // Should be a string for the default `searchMethod`, but can be anything when using a custom search.\n  searchQuery: PropTypes.any,\n  // eslint-disable-line react/forbid-prop-types\n  // Outline the <`searchFocusOffset`>th node and scroll to it.\n  searchFocusOffset: PropTypes.number,\n  // Get the nodes that match the search criteria. Used for counting total matches, etc.\n  searchFinishCallback: PropTypes.func,\n  // Generate an object with additional props to be passed to the node renderer.\n  // Use this for adding buttons via the `buttons` key,\n  // or additional `style` / `className` settings.\n  generateNodeProps: PropTypes.func,\n  // Set to false to disable virtualization.\n  // NOTE: Auto-scrolling while dragging, and scrolling to the `searchFocusOffset` will be disabled.\n  isVirtualized: PropTypes.bool,\n  treeNodeRenderer: PropTypes.func,\n  // Override the default component for rendering nodes (but keep the scaffolding generator)\n  // This is an advanced option for complete customization of the appearance.\n  // It is best to copy the component in `node-renderer-default.js` to use as a base, and customize as needed.\n  nodeContentRenderer: PropTypes.func,\n  // Override the default component for rendering an empty tree\n  // This is an advanced option for complete customization of the appearance.\n  // It is best to copy the component in `placeholder-renderer-default.js` to use as a base,\n  // and customize as needed.\n  placeholderRenderer: PropTypes.func,\n  theme: PropTypes.shape({\n    style: PropTypes.shape({}),\n    innerStyle: PropTypes.shape({}),\n    reactVirtualizedListProps: PropTypes.shape({}),\n    scaffoldBlockPxWidth: PropTypes.number,\n    slideRegionSize: PropTypes.number,\n    rowHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\n    treeNodeRenderer: PropTypes.func,\n    nodeContentRenderer: PropTypes.func,\n    placeholderRenderer: PropTypes.func\n  }),\n  // Determine the unique key used to identify each node and\n  // generate the `path` array passed in callbacks.\n  // By default, returns the index in the tree (omitting hidden nodes).\n  getNodeKey: PropTypes.func,\n  // Called whenever tree data changed.\n  // Just like with React input elements, you have to update your\n  // own component's data to see the changes reflected.\n  onChange: PropTypes.func.isRequired,\n  // Called after node move operation.\n  onMoveNode: PropTypes.func,\n  // Determine whether a node can be dragged. Set to false to disable dragging on all nodes.\n  canDrag: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),\n  // Determine whether a node can be dropped based on its path and parents'.\n  canDrop: PropTypes.func,\n  // Determine whether a node can have children\n  canNodeHaveChildren: PropTypes.func,\n  // When true, or a callback returning true, dropping nodes to react-dnd\n  // drop targets outside of this tree will not remove them from this tree\n  shouldCopyOnOutsideDrop: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),\n  // Called after children nodes collapsed or expanded.\n  onVisibilityToggle: PropTypes.func,\n  dndType: PropTypes.string,\n  // Called to track between dropped and dragging\n  onDragStateChanged: PropTypes.func,\n  // Specify that nodes that do not match search will be collapsed\n  onlyExpandSearchedNodes: PropTypes.bool,\n  // rtl support\n  rowDirection: PropTypes.string\n};\nReactSortableTree.defaultProps = {\n  canDrag: true,\n  canDrop: null,\n  canNodeHaveChildren: function canNodeHaveChildren() {\n    return true;\n  },\n  className: '',\n  dndType: null,\n  generateNodeProps: null,\n  getNodeKey: defaultGetNodeKey,\n  innerStyle: {},\n  isVirtualized: true,\n  maxDepth: null,\n  treeNodeRenderer: null,\n  nodeContentRenderer: null,\n  onMoveNode: function onMoveNode() {},\n  onVisibilityToggle: function onVisibilityToggle() {},\n  placeholderRenderer: null,\n  reactVirtualizedListProps: {},\n  rowHeight: null,\n  scaffoldBlockPxWidth: null,\n  searchFinishCallback: null,\n  searchFocusOffset: null,\n  searchMethod: null,\n  searchQuery: null,\n  shouldCopyOnOutsideDrop: false,\n  slideRegionSize: null,\n  style: {},\n  theme: {},\n  onDragStateChanged: function onDragStateChanged() {},\n  onlyExpandSearchedNodes: false,\n  rowDirection: 'ltr'\n};\npolyfill(ReactSortableTree);\n\nvar SortableTreeWithoutDndContext = function SortableTreeWithoutDndContext(props) {\n  return React.createElement(DragDropContextConsumer, null, function (_ref17) {\n    var dragDropManager = _ref17.dragDropManager;\n    return dragDropManager === undefined ? null : React.createElement(ReactSortableTree, _extends({}, props, {\n      dragDropManager: dragDropManager\n    }));\n  });\n}; // Export the tree component without the react-dnd DragDropContext,\n\n\nvar SortableTree = DndManager.wrapRoot(SortableTreeWithoutDndContext);\nexport default SortableTree;\nexport { SortableTreeWithoutDndContext, defaultGetNodeKey, defaultSearchMethod, getDescendantCount, getVisibleNodeCount, getVisibleNodeInfoAtIndex, walk, map, toggleExpandedForAll, changeNodeAtPath, removeNodeAtPath, removeNode, getNodeAtPath, addNodeUnderParent, insertNode, getFlatDataFromTree, getTreeFromFlatData, isDescendant, getDepth, find };","map":null,"metadata":{},"sourceType":"module"}